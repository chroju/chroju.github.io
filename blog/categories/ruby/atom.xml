<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | the world as code]]></title>
  <link href="http://chroju.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://chroju.github.io/"/>
  <updated>2016-01-24T23:00:42+09:00</updated>
  <id>http://chroju.github.io/</id>
  <author>
    <name><![CDATA[chroju]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Hash与えるとGoogleスプレッドシートに入力してくれるRubyスクリプト]]></title>
    <link href="http://chroju.github.io/blog/2015/05/03/google-spread-sheet-update-via-ruby/"/>
    <updated>2015-05-03T19:52:10+09:00</updated>
    <id>http://chroju.github.io/blog/2015/05/03/google-spread-sheet-update-via-ruby</id>
    <content type="html"><![CDATA[<script src="https://gist.github.com/chroju/7b9d422732f1a0ddd45e.js"></script>


<p>つくった。動きとしては、項目名と入力値からなるハッシュを引数で与えてやることで、該当スプレッドシートの2列目に符合するキーがある場合、その値を一番右側の列に入力してくれる。符合するキーがない場合は、メッセージを吐いた上で最下行に新しい項目として追加する。</p>

<p>用途としては非常に個人的なもので、各種オンラインバンクの残高をスクレイピングしてハッシュで返してくれるスクリプトをいくつか作ってあったので、その戻り値を使ってオートで家計簿作れたらいいなーという思いによるものです。ハッシュのキーをそのままスプレッドシート内の項目名として使っているので、シンボルではなく文字列をキーとして使ってしまっているのがあまりよろしくないのかなぁとは思うのだが、いつか改善するってーことで、とりあえず動くものを作ることを優先させた。んで、これって結構汎用的に使えそうなスクリプトかもなと思って公開した次第。</p>

<p>Googleスプレッドシートをいじるのには<code>google-drive-ruby</code>というGemを使ってます。Githubは<a href="https://github.com/gimite/google-drive-ruby">ここ</a>。<code>def initialize</code>内の処理は、このGemの初期設定によるものなので、Gemの方のReadme読んでもらえればよいかと。単純な話、GoogleのOAuth API使っているだけの話です。ただ、このコードだと叩くたびにブラウザからAPI使用許可を与えてやって、success codeをコピーしてコマンドラインで入力してやらなくちゃならないっていう手間があって、そこまで省く方法なにかありそうだけどまだ調べてない。あと気になっている点としては、このGemでセルの値を取ると、表示値しか取れないこと。式を入れているセルについては、式を取るか表示値を取るか選べるといいなぁと思ったんだけど、そこまではできないらしい。しかしまぁ、とにかくGoogleスプレッドシートという、APIで叩けるクラウドの表計算ソフトがあるというのは本当に便利なことですね、って感じ。</p>

<h2>参考</h2>

<ul>
<li><a href="http://qiita.com/inokappa/items/2566b21f4b1deac6f95b">RubyからGoogle SpreadSheet をいじるメモ - Qiita</a></li>
<li><a href="http://qiita.com/yumiyon/items/d7c370b3b8582431a3de">Google DriveのスプレッドシートにRubyでアクセスする方法 - Qiita</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby基礎学習(10) Mix-in]]></title>
    <link href="http://chroju.github.io/blog/2015/04/24/ruby-study-mix-in/"/>
    <updated>2015-04-24T07:22:17+09:00</updated>
    <id>http://chroju.github.io/blog/2015/04/24/ruby-study-mix-in</id>
    <content type="html"><![CDATA[<p>Mix-inの話と、それに似たもろもろ。他に詳しい記事があるので、これを読んでおけばいいような気はした。</p>

<h2>参考</h2>

<ul>
<li><a href="http://faultier.blog.jp/archives/1220074.html">requireとincludeとextendとmodule_function(1) : As Sloth As Possible</a></li>
<li><a href="http://faultier.blog.jp/archives/1220088.html">requireとincludeとextendとmodule_function(2) : As Sloth As Possible</a></li>
</ul>


<h2>require</h2>

<ul>
<li>Kernelモジュールのモジュール関数。</li>
<li>引数に与えたRubyライブラリを1回ロード、というか実行する。</li>
<li>使う場面としてはgemだとか自作のライブラリ（クラス）を読み込むときに指定する。</li>
<li>指定した引数は$LOAD_PATHに探しに行き、カレントディレクトリは含まれないため、パスの指定には少し注意が必要。</li>
<li>同じファイルを複数回requireしようとしても、1回しか読み込まない。</li>
</ul>


<h2>load</h2>

<ul>
<li>Kernelモジュールのモジュール関数。</li>
<li>requireと同様に外部ライブラリを実行するが、同じファイルを何度でも読み込める。</li>
<li>requireは拡張子の自動補完を行うが、loadは行わない。</li>
</ul>


<h2>include</h2>

<ul>
<li>Moduleクラスのインスタンスメソッド。</li>
<li>Moduleを引数に取り、メソッドや定数といった対象Moduleの性質を取り込む。</li>
<li>ArrayやHashがEnumerableの性質を持っているのはincludeしていることによるもの。</li>
<li>継承とは異なるが、メソッドの探索対象としてはスーパークラスよりincludeされたModuleの方が先になる。</li>
<li>同じモジュールを複数回読み込もうとしても、2回目以降は無視される。</li>
<li>Rubyは多重継承を認めていないが、その代わりの機能を果たすという位置付けらしい。</li>
</ul>


<h2>extend</h2>

<ul>
<li>Objectクラスのインスタンスメソッド。</li>
<li>引数に取ったModuleのメソッドを特異メソッドとして取り込める。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby基礎復習(9) Dirクラス]]></title>
    <link href="http://chroju.github.io/blog/2015/04/14/study-ruby-dir/"/>
    <updated>2015-04-14T22:45:02+09:00</updated>
    <id>http://chroju.github.io/blog/2015/04/14/study-ruby-dir</id>
    <content type="html"><![CDATA[<p>『パーフェクトRuby』p.208より。</p>

<p>Dirクラスは基本としてカレントディレクトリ情報を持っていて、それを元としてディレクトリ操作ができる。従って多くの操作を特異メソッドで行うことができる。</p>

<pre><code class="ruby">Dir.pwd # =&gt; "/Users/chroju"
Dir.chdir("/tmp")
Dir.pwd # =&gt; "/tmp"
Dir.home # =&gt; "/Users/chroju"
</code></pre>

<p>ディレクトリに含まれるファイルは<code>Dir.entries</code>で配列として返り、<code>Dir.foreach</code>でEnumerableとして返る。また<code>Dir.glob</code>により、パターンにマッチするファイルパスを配列で返すこともできる。<code>Dir.glob</code>は<code>Dir[]</code>と同義である。引数のディレクトリが存在するか確認する場合は<code>Dir.exists?</code>を用いる。</p>

<pre><code class="ruby">Dir.entries('.') # =&gt; [".", "..", "bar", "foo", "baz"]
Dir.foreach('.') {|d|
  p d
} # =&gt; ".", "..", "bar", "foo", "baz"
Dir.glob('ba*') # =&gt; ["bar", "baz"]
Dir['ba*'] # =&gt; ["bar", "baz"]
Dir.exists?("hoo") # =&gt; false
</code></pre>

<p>ディレクトリの削除、生成等も特異メソッドにて。</p>

<pre><code class="ruby">Dir.mkdir 'foo', 0755 # パーミッション0755でfooディレクトリを生成
Dir.rmdir 'foo' # fooディレクトリを削除するが、対象ディレクトリは空である必要がある
Dir.delete 'foo' # Dir.rmdirと同義
Dir.unlink 'foo' # Dir.rmdirと同義
</code></pre>

<p><code>Dir.open</code>すると、Dirオブジェクトを取得することができ、インスタンスメソッドによる操作が可能になる。Dirオブジェクトは読み込み位置を持っていて、ディレクトリ内のファイル名を1つずつ読み込ませることができる。</p>

<pre><code class="ruby">dir = Dir.open('.')
dir.path # =&gt; "/temp" （現在のファイルパス）
dir.pos # =&gt; 0 （現在の読み込み位置）
dir.pos = 1 # 読み込み位置を移動
dir.read # =&gt; ".."
dir.rewind # 読み込み位置を先頭に戻す
dir.read # =&gt; "."
dir.each {|f| p f} # =&gt; ".", "..", "bar", "baz", "foo"
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby基礎復習(8) Fileクラス]]></title>
    <link href="http://chroju.github.io/blog/2015/04/10/study-ruby-file-i-o/"/>
    <updated>2015-04-10T23:06:03+09:00</updated>
    <id>http://chroju.github.io/blog/2015/04/10/study-ruby-file-i-o</id>
    <content type="html"><![CDATA[<p>『パーフェクトRuby』p.196より。わりと苦手な分野。</p>

<p>まずはファイルをひらく。<code>#open</code>して変数に格納してもいいし、ブロックを引き渡して処理させることもできる。後者の場合は処理が終わると自動でクローズしてくれるので、こっちの方が楽っぽい。<code>#read</code>はファイルの内容全体を読み込む一方、<code>#gets</code>を使うと1行ずつ読み込むことができる。あるいは<code>#each_line</code>や<code>#each_char</code>といったメソッドも。</p>

<pre><code class="ruby">file = File.open('example.txt')
p file.read # example.txtの内容を表示
file.close

File.open 'example.txt' do |file|
  p file.read
end

File.read('example.txt')

File.open 'example.txt' do |file|
  while line = file.gets
    p line
  end
end

File.open 'example.txt' do |file|
  f.each_line do |line|
    p line
  end
end
</code></pre>

<p>書き込むときは<code>#open</code>の第二引数にファイルを開くモードを指定する。デフォルトは<code>'r'</code>、すなわち読み込みモードで、他は以下の通り。基本は<code>r</code>が読み込み、<code>w</code>が書き込み、<code>a</code>が追記で、<code>+</code>を付けると読み書き両用モードになる。また<code>b</code>を後置するとバイナリモードで開かれる。</p>

<p>| r  | 読み込みモード         |
| r+ | 読み書き両用モード（読み書き位置は先頭から）       |
| w  | 上書き書き込みモード   |
| w+ | 新規作成して読み書き両用モード |
| a  | 追記書き込みモード       |
| a+ | 追記読み書き両用モード（読み込み位置は先頭から、書き込みは追記形式）  |</p>

<pre><code class="ruby">File.open 'example.txt', 'w' do |f|
  f.write 'hoge'
end
</code></pre>

<p>もっと単純に<code>#write</code>メソッドだけでも書き込み可能。</p>

<pre><code class="ruby">File.write 'example.txt', 'fuga'
</code></pre>

<p>先のファイルを開くモードの話の中で「読み込み位置は先頭から」という表現があったが、IOオブジェクトではファイル内の今どこを読み／書きしているかというアクセス位置が存在する。<code>#gets</code>では1行ずつ読み込みを行ったように、読み／書きを行うことでアクセス位置は進んでいく。先頭まで戻りたい場合は<code>#rewind</code>を使う。また<code>#seek</code>メソッドは第二引数に定数で指定した基準位置より、第一引数の整数分アクセス位置を移動させることができる。<code>#pos</code>は絶対的にアクセス位置を指定して動かせる。</p>

<pre><code class="ruby">File.open 'example.txt' do |f|
  f.puts
  f.rewind # 先頭位置まで戻る

  f.seek 10 # 先頭から10進む
  f.seek -10, IO::SEEK_END # 末尾（SEEK_END）から10戻った位置に移動

  f.pos = 25 # 先頭から25バイト目に移動
  f.pos # =&gt; 25
end
</code></pre>

<p>文字のエンコーディングについては、「外部」と「内部」という概念を持つ。外部はファイルのエンコーディング情報であり、内部はRuby上で処理する際のエンコーディング情報。例えばEUC-JPのファイルをutf-8で変換して取り扱い、書き込みはEUC-JPで、といったことができる。エンコーディングの設定には<code>#set_encoding</code>メソッドを使う。引数を1つだけ取る場合は外部エンコーディングを設定し、2つ取る場合は第一引数が外部、第二引数が内部を設定する。あるいは<code>File#open</code>するときに、読み書きモードと一緒にエンコーディングも指定することができる。</p>

<pre><code class="ruby">File.open 'example.txt' do |f|
  f.set_encoding('utf-8') # 外部エンコーディングをutf-8に設定

  f.set_encoding('utf-8', 'EUC-JP') # 外部エンコーディングをutf-8、内部エンコーディングをEUC-JPに設定
  f.set_encoding('utf-8:EUC-JP') # 外部エンコーディングをutf-8、内部エンコーディングをEUC-JPに設定
end

File.open 'example.txt', 'r:utf-8:EUC-JP' do |f|
  p f.external_encoding # =&gt; "utf-8"
  p f.internal_encoding # =&gt; "EUC-JP"
end
</code></pre>

<p>ファイルのロックには<code>#flock</code>メソッドを利用する。ロックのモードは<a href="http://docs.ruby-lang.org/ja/1.9.3/method/File/i/flock.html">ここに記載の定数</a>を使って指定するのだが、主に<code>File::LOCK_EX</code>が排他ロックであることを覚えとけばいいような気も。</p>

<pre><code class="ruby">File.open 'example.txt', 'w' do |f|
  f.flock File::LOCK_EX
end
</code></pre>

<p>その他、ファイル情報取得系のメソッドをつらつらと。これらはファイルオブジェクトから取得するだけではなく、<code>File.atime(filename)</code>の形で<code>File</code>クラスのクラスメソッドでも呼び出すことができる。</p>

<pre><code class="ruby">File.open 'example.txt' do |f|
  f.atime # 最終アクセス日時
  f.ctime # 最終変更日時
  f.mtime # 最終更新日時

  f.size # ファイルサイズ

  f.ftype # ファイルタイプ 以下真偽判定メソッドも有り
  f.file?
  f.directory?
  f.symlink?

  f.writable? # =&gt; false
  f.readable? # =&gt; true
  f.executable? # =&gt; false

  f.owned? # =&gt; false (自身がファイル所有者か？)
  f.gid # ファイル所有者のGID
  f.uid # ファイル所有者のUID
end
</code></pre>

<p>ファイル操作系。</p>

<pre><code class="ruby"># ファイル名変更、ファイル移動
File.rename 'hoge', 'fuga'
File.rename 'hoge', 'dir/hoge'

# ファイル削除
File.unlink 'hoge'

# シンボリックリンク作成
File.symlink 'target', 'link'

# ハードリンク作成
File.link 'target', 'link'

# ファイルモード変更
File.chmod 0600, 'filename'

# 所有者、グループの変更
File.chown 100, 100, 'filename'
</code></pre>

<p>ファイルパスに関するもろもろ。</p>

<pre><code class="ruby"># ファイルのあるディレクトリパスの取得
File.dirname("etc/sample.txt") # =&gt; "/etc"

# 第一引数に与えたファイルパスに対する、ファイル名の取得。第二引数でsuffix指定。
File.basename("etc/sample.txt") # =&gt; "sample.txt"
File.basename("etc/sample.txt", ".txt") # =&gt; "sample"

# 拡張子の取得
File.extname("etc/sample.txt") # =&gt; ".txt"

# ファイルパスの連結（引数は可変長）
File.join("/usr/local", "bin/ruby") # =&gt; "/usr/local/bin/ruby"

# ファイルパスからdirnameとbasenameを取得し配列生成
File.split("/usr/local/bin/ruby") # =&gt; ["/usr/local/bin", "ruby"]

# 絶対パスの展開
File.expand_path("~") # =&gt; "/home/chroju"
File.expand_path("filename", "~") # =&gt; "/home/chroju/filename"

# absolute_pathでは~を展開しない
File.absolute_path("~") # =&gt; "/home/chroju/~"
</code></pre>

<p>Dirクラスも触れたいのだが、長くなるので一旦ここまで。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby基礎復習(7) Timeクラス]]></title>
    <link href="http://chroju.github.io/blog/2015/04/06/study-ruby-time/"/>
    <updated>2015-04-06T22:53:30+09:00</updated>
    <id>http://chroju.github.io/blog/2015/04/06/study-ruby-time</id>
    <content type="html"><![CDATA[<p>『パーフェクトRuby』p.190より。</p>

<p><code>Time#now</code>か<code>Time#new</code>で現在時刻が取得可能。</p>

<pre><code class="ruby">now = Time.now # =&gt; 2015-03-16 23:25:32 +0900
new = Time.new # =&gt; 2015-03-16 23:25:32 +0900

now.zone # =&gt; "JST"
now.getutc # =&gt; 2015-03-16 14:25:32 UTC
now.utc
now.zone # =&gt; "UTC"
</code></pre>

<p>現在時刻以外のTimeオブジェクトを生成するには<code>Time#at</code>でUNIX秒を引数に指定するか、<code>Time#utc</code>か<code>Time#local</code>で直接時刻を指定する。</p>

<pre><code class="ruby">Time.at(0) # =&gt; 1970-01-01 09:00:00 +0900
Time.utc(2015, 1, 1, 2, 30, 40, 100) # =&gt; 2015-01-01 02:30:40 UTC (最後の100はマイクロ秒)
Time.local(2015, 1, 1, 2, 30, 40, 100) # =&gt; 2015-01-01 02:30:40 +0900
</code></pre>

<p><code>#to_i</code>、<code>#to_f</code>、<code>#to_r</code>の戻り値はUNIX秒。<code>#to_s</code>で文字列表現が返る。<code>#to_a</code>は秒、分、時、日、月、年、曜日、その年の通算日数、夏時間の真偽判定、タイムゾーンの配列を返す。なお、この配列フォーマットを展開して<code>Time#utc</code>や<code>Time#local</code>の引数として与えることもできる。</p>

<pre><code class="ruby">now.to_i # =&gt; 1426515932
now.to_f # =&gt; 1426515932.978824
now.to_r # =&gt; (178314491622353/125000)
now.to_s # =&gt; "2015-03-16 23:25:32 +0900"
now.to_a # =&gt; [32, 25, 23, 16, 3, 2015, 1, 75, false, "JST"]
</code></pre>

<p><code>#to_s</code>の戻り値は上記フォーマットの固定だが、任意のフォーマットで文字列表現を得たい場合は<code>#strftime</code>を使う。使えるフォーマット文字列は<a href="http://docs.ruby-lang.org/ja/1.9.3/class/Time.html">公式ドキュメント</a>参照で。</p>

<pre><code class="ruby">now.strftime("今日は%Y年%m月%d日、今は%H時%M分を%S秒過ぎたところです。") # =&gt; "今日は2015年3月16日、今は23時25分を32秒過ぎたところです。"
</code></pre>

<p>逆に文字列表現からTimeオブジェクトを得たい場合は<code>#strptime</code>が使える。</p>

<h2>参照</h2>

<ul>
<li><a href="http://qiita.com/riocampos/items/de59263ac4e991a98f49">Ruby - 日本語表記の日時をTimeオブジェクトに変換（Time.strptimeメソッド） - Qiita</a></li>
</ul>


<p>その他もろもろの出力。</p>

<pre><code class="ruby">now.year # =&gt; 2015
now.month # =&gt; 3
now.day # =&gt; 16
now.hour # =&gt; 23
now.min # =&gt; 25
now.sec # =&gt; 32
now.nsec # =&gt; 978824000 (ナノ秒)
now.wday # =&gt; 1 (曜日は日曜を0としてカウント)
now.yday # =&gt; 75 (年初からの日数)
</code></pre>

<p>曜日やサマータイム(DST)については疑問符のメソッドで真偽判定できる。</p>

<pre><code class="ruby">now.dst? # =&gt; false
now.sunday? # =&gt; false
now.monday? # =&gt; true
</code></pre>

<p>Timeオブジェクト同士の比較についてはナノ秒まで判定されるので、そのあたりに注意とのこと。以下のようなことがあり得る。</p>

<pre><code class="ruby">now = Time.now # =&gt; 2015-03-16 23:25:32 +0900
new = Time.new # =&gt; 2015-03-16 23:25:32 +0900

now == new # =&gt; false
</code></pre>

<p>整数を与えることによる加算減算は秒として取り扱われる。Timeオブジェクト同士の減算も可能。その場合は差分の秒数が浮動小数点数で返る。</p>

<pre><code class="ruby">now = Time.now # =&gt; 2015-03-16 23:25:32 +0900

now + 1 # =&gt; 2015-03-16 23:25:33 +0900
now - 1 # =&gt; 2015-03-16 23:25:31 +0900
</code></pre>

<p>なお時間や日時を扱うクラスには他に<code>Date</code>や<code>DateTime</code>もあるが、組み込みのライブラリはこの<code>Time</code>だけ。どれを使えばええんや？ってのは、探してみたら大変詳しいQiitaを見つけたんでそっちに譲ります。</p>

<h2>参考</h2>

<ul>
<li><a href="http://qiita.com/jnchito/items/cae89ee43c30f5d6fa2c">RubyとRailsにおけるTime, Date, DateTime, TimeWithZoneの違い - Qiita</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
