<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linux on the world as code</title>
    <link>https://chroju.github.io/categories/linux/</link>
    <description>Recent content in Linux on the world as code</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <copyright>written by chroju</copyright>
    <lastBuildDate>Sun, 28 Sep 2014 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://chroju.github.io/categories/linux/atom.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>awesomeウィンドウマネージャーの見栄えを良くする</title>
      <link>https://chroju.github.io/blog/2014/09/28/2014-09-28-post/</link>
      <pubDate>Sun, 28 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>https://chroju.github.io/blog/2014/09/28/2014-09-28-post/</guid>
      <description>Arch Linuxで使っているデスクトップマネージャ、awesomeのテーマに若干手を入れてみたので備忘録。あんまり日本語ドキュメントないので、このあたりのカスタマイズしんどかったです。
テーマファイルの構成 awesomeの設定はいくつかのLuaファイルを使って書き換えていく。基本的には全体設定を司る~/.config/awesome/rc.luaと、外観やテーマを司るライブラリである、Beautifulの設定ファイル~/.config/awesome/themes/default/theme.luaの2つを覚えておけばいいのかなと。いずれも初期状態では配置されてないので、デフォルトファイルをコピーしてきて使う。
# cp /etc/xdg/awesome/rc.lua ~/.config/awesome/rc.lua # cp -r /usr/share/awesome/themes/default ~/.config/awesome/themes/default  Beautifulについてはrc.luaの中で設定ファイルのパスが指定できるので、defaultという名前が嫌だったら任意で変えてもOK。あとは正直awesomeのWiki見るのが手っ取り早いとは思うのだが、設定したところだけ書いておく。ちなみに前回記事で書いたが、awesomeのデフォルトターミナルの設定もrc.luaを使うので、外観変える必要なくてもrc.luaだけは確実に要ると思う。
タグリストの書き換え awesomeでは仮想デスクトップを&amp;rdquo;tag&amp;rdquo;と呼んで扱っていて、デフォルトの状態だと左上に1から8まで（だったかな？）の数字がタグの番号として並んでいる。あまりわかりやすいものではないし、そんなに多くタグも使わないので書き換える。
tags = &amp;lt;span class=&amp;quot;synType&amp;quot;&amp;gt;{}&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;quot;synStatement&amp;quot;&amp;gt;for&amp;lt;/span&amp;gt; s = &amp;lt;span class=&amp;quot;synConstant&amp;quot;&amp;gt;1&amp;lt;/span&amp;gt;, screen.count() &amp;lt;span class=&amp;quot;synStatement&amp;quot;&amp;gt;do&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;quot;synComment&amp;quot;&amp;gt;-- Each screen has its own tag table.&amp;lt;/span&amp;gt; tags[s] = awful.tag(&amp;lt;span class=&amp;quot;synType&amp;quot;&amp;gt;{&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;quot;synConstant&amp;quot;&amp;gt;&amp;quot;Firefox&amp;quot;&amp;lt;/span&amp;gt;, &amp;lt;span class=&amp;quot;synConstant&amp;quot;&amp;gt;&amp;quot;Terminal&amp;quot;&amp;lt;/span&amp;gt;, &amp;lt;span class=&amp;quot;synConstant&amp;quot;&amp;gt;&amp;quot;Vim&amp;quot;&amp;lt;/span&amp;gt;, &amp;lt;span class=&amp;quot;synConstant&amp;quot;&amp;gt;&amp;quot;other&amp;quot;&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;quot;synType&amp;quot;&amp;gt;}&amp;lt;/span&amp;gt;, s, layouts[&amp;lt;span class=&amp;quot;synConstant&amp;quot;&amp;gt;1&amp;lt;/span&amp;gt;]) &amp;lt;span class=&amp;quot;synStatement&amp;quot;&amp;gt;end&amp;lt;/span&amp;gt;  あとウィンドウを開いているタグは小さな正方形が表示されたりしていて鬱陶しかったのと、あまり見栄えも良くなかったので、正方形を表示されないようにした上で、フォーカスしているタグは文字色を変えることにした。これはbeautifulの方で設定する。
theme.taglist_fg_focus = &amp;lt;span class=&amp;quot;synConstant&amp;quot;&amp;gt;&amp;quot;#f15c22&amp;quot;&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;quot;synComment&amp;quot;&amp;gt;-- theme.taglist_squares_sel = &amp;quot;/usr/share/awesome/themes/default/taglist/squarefw.png&amp;quot;&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;quot;synComment&amp;quot;&amp;gt;-- theme.</description>
    </item>
    
    <item>
      <title>Arch Linux &#43; awesome with Windows 8.1 in VAIO Pro</title>
      <link>https://chroju.github.io/blog/2014/09/23/2014-09-23-post/</link>
      <pubDate>Tue, 23 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>https://chroju.github.io/blog/2014/09/23/2014-09-23-post/</guid>
      <description>先日VirtualBoxでArch Linux入れてみたところでしたが、引き続いてVAIO Proへのインストールが完了したのでまとめます。なお、Window8.1とのデュアルブートです。上のスクリーンショットが完成形。
事前準備 まず起動前の状態でASSISキーを押してBIOS設定を呼び出し、Secure Bootをdisabledにしておきます。Arch LinuxではSecure Bootをサポートしてないです。あとここではExternal MediaでのBootを許可したりとかしておくべきなんですけど、怠惰なんでASSISTメニューからUSBメモリでの起動を選ぶことでインストール作業を済ませてしまいました。Arch Wikiには「External MediaいじってUSBブートしろ」って書いてあるんで、そっちに従った方がいいと思います。
続いてWindows側での設定。
 コントロールパネル &amp;gt; 電源オプション &amp;gt; 電源ボタンの動作の選択 &amp;gt; 高速スタートアップを有効にする をオフ スタートボタン右クリック &amp;gt; ディスクの管理 &amp;gt; パーティションを縮小  既存パーティションを縮めることでLinuxインストール用の領域を作るのが通例ですけど、自分の場合これだ空き容量が小さすぎたので、回復パーティションを削除することにしました。そのために16GBのUSBメモリを買ってきて、回復ドライブを作ります。
VAIO Care  その他の機能  リカバリーメディアの作成 作成が無事に終わったら、その後一度シャットダウンしてASSISTキー押して起動。以下の手順でリカバリーパーティションが消せます。
トラブルシューティングを開始  Microsoft IME  トラブルシューティング  VAIOのリカバリー機能  Windows 8.1  ツール  リカバリーパーティションを削除 が、自分の場合これだとエラーが出て結局ダメだったんでdiskpartで削除しました。これもあまり褒められたやり方ではないと思うので推奨はしません。256GBモデルをケチらず買っときゃよかったなと初めて思った次第。
インストール インストール用のUSB指して再度ASSISTキーを押し、USBメディアから起動。そこからは前回のエントリーを参考に、通常通りインストール進めていきます。ポイントは以下の点かなと。
 ディスクパーティション、ESPはWindowsのものを使うので新たな切り出し不要。自分は/mnt/boot(200MB)と/mnt(残り全部)だけ切りました。 実際にインストールしていく段階ではネット接続が必要だが、wifi-menuでWi-Fi接続できる。意外に簡単。 インストール後の設定作業でもwifi-menuを使えるようにするため、pacstrapするときにdialogとwpa_supplicantも入れておく。  だいたいブートローダーの設定前までは特にハマるポイントはないはず。
ブートローダーの設定 grub-installまで完了すると、/boot内は次のような感じになりました。
/boot/efi/EFI/Microsoft/Boot/bootmgfw.efi /boot/efi/EFI/grub/grubx64.efi  ……efiがダブったパスになったのあれなんですけど、とりあえずここで言いたいのはもともとのWindowsのブートローダーとgrubがダブりますねという話で、勝手にgrubの方を上げてくれればいいんですけど、このPCの場合なのかWindows8の場合なのかわかりませんが、bootmgfw.efiの方がどうしても呼ばれてしまうので、パスを変える必要があります。
$ cd /boot/efi/EFI/Microsoft/Boot/ $ mv bootmgfw.</description>
    </item>
    
    <item>
      <title>VirtualBoxでArch Linuxのインストール練習</title>
      <link>https://chroju.github.io/blog/2014/09/07/2014-09-07-post/</link>
      <pubDate>Sun, 07 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>https://chroju.github.io/blog/2014/09/07/2014-09-07-post/</guid>
      <description>VAIO Proにcygwin入れたりして頑張っていたのだが、そろそろしんどくなってきたので、まともに開発に使える環境作るかーってことでデュアルブートを試みることに。デュアルじゃなくてOS丸ごと入れ替えたら？という話もありそうだが、仕事で使うのでWindowsを潰せない。かと言って仮想マシンだとこのPCのスペックでは心許ない。。ってことでデュアル。
ではディストリは何を使うか？だが、以前Ubuntuを使ったデュアルブートは構築した経験があるし、GUIでポチポチインストールするんじゃあんまり勉強にはならなさそうだなーということで、思い切ってArch Linuxを選んだ。ミニマルを是とするディストリだが、ミニマルどころか最初はsudoすら入っていないという徹底っぷり。使うものだけ入れろ！というポリシーは大変に共感できるものではあるが、それは当然難易度の高さと引き換えなわけで。。
さすがにぶっつけ本番は怖すぎるので、まずはiMac(OS X Marverics)上のVirtualboxでデスクトップ環境が立ち上がるとこまでやってみた。難易度が確かに高いOSではあるが、Wikiが非常に充実しているので、案外迷うこともないとは思う。逆に言えば、ここのInstallation GuideとBeginner&amp;rsquo;s Guideにきちんと目を通した上でやるべき。こんなブログ記事だけに頼らずに。
なお、えっらい長い記事になった模様。
事前チェック VAIO ProがUEFI環境なんで、今回の練習でもUEFIを用いることにした。Virtualboxの場合は仮想マシンの設定から「UEFI」を有効化できる。他にも初期設定ではインストールメディアをつないだり、外部メディアからの起動準備を優先させたりして、準備完了。
起動するといきなりシェルが現れる。ここから全部自力でコマンド打って入れてけというストイックさ。ひとまずはUEFIで起動しているか確認するため、UEFI変数を表示。
# mount -t efivarfs efivarfs /sys/firmware/efi/efivars # efivar -l  続いてキーボードマッピング変更。 jp106とかusとか適宜。やらなくてもインストールぐらいはなんとかなるかもしれんが、viでコロンの位置違ったりすると不便。地味に。
# loadkeys hoge  事前チェックはこれぐらい。
パーティション 続いてパーティション分割。まずはfdisk -lによりハードディスクのデバイス名を確認し、そのデバイス名に対してcgdiskコマンドを実行。今回はGPTを用いるのでcgdiskだが、MBRならcfdiskでよい。あるいはgdiskやfdiskもあるけど、やりづらいので自分はcを頭に付ける。
なおMBRとGPTの選択に関してはwiki内に記述がある。
ブートローダに GRUB Legacy を使う場合、MBR を使うべきです。 古い BIOS を使う Windows (32ビット、64ビット両方) とのデュアルブートをするなら、MBR を使うべきです。 BIOS の代わりに UEFI を使う64ビットの Windows とデュアルブートをするなら、GPT を使うべきです。 [https://wiki.archlinux.org/index.php/Partitioning_(%E6%97%A5%E6%9C%AC%E8%AA%9E)](https://wiki.archlinux.org/index.php/Partitioning_(%E6%97%A5%E6%9C%AC%E8%AA%9E)) 分け方はわりと適当。swapはまぁ、なくてもいいかなと。
 ESP(EFI System Partition)用に512MB
 タイプコードはef00
 FAT32でフォーマットする (https://wiki.archlinux.org/index.php/Unified_Extensible_FirmwareInterface(%E6%97%A5%E6%9C%AC%E8%AA%9E)))
 デュアルブートの場合はすでにWindows側で作られているので要らないはず。
 /bootに200MBぐらい</description>
    </item>
    
    <item>
      <title>SSHでサーバーリモートログインする際のあれこれまとめ</title>
      <link>https://chroju.github.io/blog/2013/12/08/2013-12-08-post/</link>
      <pubDate>Sun, 08 Dec 2013 00:00:00 +0000</pubDate>
      
      <guid>https://chroju.github.io/blog/2013/12/08/2013-12-08-post/</guid>
      <description>うちのには仮想開発環境としてCent OSが立っているんだけど、この前コイツの中で作っているプロジェクトをGithubに突っ込もうと思ったらGithubで登録してるRSA認証のキーフレーズ忘れてて軽く詰んだ。で、仕方ないのでもっかい鍵作ってやり直そうと思ったら、SSHの鍵認証のやり方とかそのへんも全部吹っ飛んでたので改めてまとめ直しとくことにする。やったことまとめないのダメ、絶対。
環境 今回はいわゆる「リモートのサーバーにSSHを使ってログインする」場合と「GithubにSSHでpushする」場合を想定する。使用するクライアントはMac OS X、サーバーはCent OS。ちなみにシェルはbash。
そもそもSSHってなんぞや セキュアなリモート通信用プロトコル。セキュアな、と言っているのはTelnetあたりが平文でパスワード贈っちゃうのに対して、SSHが暗号化に対応している点を指す。で、暗号化には今多くの場合RSA（公開鍵暗号方式）を用いているらしい。だから秘密鍵と公開鍵を作ってローカルとリモートにそれぞれ配置して云々という設定が必要になる。あとGitHubもリモートレポジトリにつなぐ時にSSHが使える。
リモートサーバー接続手順 まずリモートサーバーにSSHでつなぐときの手順。
1. 認証鍵の生成 Linuxには鍵生成のコマンドがあるので、それを使う。
ssh-keygen -t rsa -tが鍵のタイプを示すオプション。ここではrsaを使うのでそのまま。あとは促されるままに保存先ディレクトリとパスフレーズを入力してやれば鍵が生成される。パスフレーズは忘れるとどうにもならんので絶対控える。絶対控える。
作成された鍵はデフォルトだと~/.ssh/配下に置かれる。id_rsaが秘密鍵でid_rsa.pubが公開鍵。
2. 公開鍵の転送 鍵が出来上がったので、早速だが公開鍵をリモートサーバーに転送してやる。転送の方法はいろいろ考えられる（一番アレな手段だと中身コピペしちゃえばいいだけだったりする。単なるテキストだし）けど、scp使うのが個人的には楽かな、と。まぁscpもSSH利用したファイル転送なので、SSH使うためにSSH使っているという矛盾っぽいところはあるんだが。細かいことは置いといて。
scp ~/.ssh/id_rsa.pub hoge@fuga.com:~/.ssh/ SCPコマンドの第一引数が送るファイル、第二引数が転送先のユーザー名@ホスト名:ファイルパス。通信するときに指定したユーザー名のパスワードを聞かれるので答えてやる。SSHの認証の方式はいくつかあって、デフォルトではパスワード認証の設定になっているので、こういうログインの仕方になる。今このエントリの作業でやっているのは、パスワード認証から公開鍵認証に変えるための手順。
ちなみにホスト名は当然ながら名前解決出来なきゃアウトなので、ローカルの開発環境とかだったらhostsに入れとくとかなんとか忘れずに。あと俺みたいにSSH1回設定したんだけどいろいろ忘れちゃったんでもっかい鍵作ってまーす(ﾉω・)ﾃﾍ)みたいな人（あんまいないだろうが）はすでにリモート側のsshd_configが書き換わってたりするので注意。ていうか俺が少しやられた。
例えばセキュリティ面の配慮でポート番号を22から変えてると当然ながら通信できない。-Pオプションでポート番号を明示的に指定する。あるいはすでにSSHをパスワード認証で使うのをNGにしてる場合もある。これについては後述。
3. 公開鍵の登録 今度はリモートサーバー側に入って、送られた公開鍵のファイル名を替えてやる。
mv ~/.ssh/id_rsa.pub ~/.ssh/authorized_keys authorized_keysが公開鍵登録用ファイルの名前。複数の公開鍵を登録することもできる。その場合は改行挟んで追記でいいのかな。アクセス元を制限してやったりとかできる記法もあるらしいが、ここでは割愛。
あとアクセス権も変える。
chmod 600 ~/.ssh/authorized_keys 4. sshd_configの設定 リモートホスト側の/etc/ssh/sshd_configファイルがSSHの設定ファイルになっているので、公開鍵認証が出来るよう、設定を書き換える。
RSAAuthentication yes PubkeyAuthentication yes AuthorizedKeysFile .ssh/authorized_keys 読めば字の如くだが、上からRSA認証許可、公開鍵認証許可、公開鍵ファイルパスの指定。デフォルトでは全部コメントアウトされていると思うので、#を外して設定を有効化する。おそらく一番下のオプション書き換えでauthorized_keysファイル以外のファイルも公開鍵に指定できるんだと思うけど、やったことないのでわからん。
逆にパスワード認証（SCPでさっき使ったヤツ）はこれで要らなくなるので無効化する。
PasswordAuthentication no ChallengeResponseAuthentication no 上がパスワード認証の不許可。下はチャレンジレスポンス認証の不許可。こちらもnoにしとかないとパスワード認証が完全にオフにならないとどっかで聞いた。うろ覚え。。。
あと気になるようであれば、port行を変えればポート番号も変えられる。22はウェルノウンポートなので、変えておいた方が無差別な攻撃は防げるはず。
書き換えたらsshサービスを再起動してフィニッシュ。
/etc/init.d/sshd restart これでローカル側からsshコマンド打ってやればつながる。パスワードを聞かれたら、公開鍵作る時に入れたパスフレーズを答えればOK。
5. Githubにつなぐ場合 Githubにつなぐときは公開鍵の中身を全部コピーして、GithubのAccount Settings &amp;gt; SSH Keysにベタッと貼り付けてやればそれでOK。はじめはリモートホストにつなぐときと別の鍵を生成してやった方がよいのかな？とか思ってしまったが、公開鍵認証の意味を考えてみると、別の鍵を作ってやる必要はなかったので特にこれで問題はない。ちなみに俺の話をすると、これまで.ssh配下にcentosとかgithubとかフォルダ作ってそれぞれの鍵ファイルを管理してた。うん、無駄だったんやね……。
リモート側のサーバーで環境共有したい場合はgit cloneで持ってくる。</description>
    </item>
    
  </channel>
</rss>