<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ruby on the world as code</title>
    <link>http://chroju.github.io/categories/ruby/</link>
    <description>Recent content in Ruby on the world as code</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Sun, 03 May 2015 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://chroju.github.io/categories/ruby/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Hash与えるとGoogleスプレッドシートに入力してくれるRubyスクリプト</title>
      <link>http://chroju.github.io/blog/2015/05/03/google-spread-sheet-update-via-ruby/</link>
      <pubDate>Sun, 03 May 2015 00:00:00 +0000</pubDate>
      
      <guid>http://chroju.github.io/blog/2015/05/03/google-spread-sheet-update-via-ruby/</guid>
      <description>

&lt;script src=&#34;https://gist.github.com/chroju/7b9d422732f1a0ddd45e.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;つくった。動きとしては、項目名と入力値からなるハッシュを引数で与えてやることで、該当スプレッドシートの2列目に符合するキーがある場合、その値を一番右側の列に入力してくれる。符合するキーがない場合は、メッセージを吐いた上で最下行に新しい項目として追加する。&lt;/p&gt;

&lt;p&gt;用途としては非常に個人的なもので、各種オンラインバンクの残高をスクレイピングしてハッシュで返してくれるスクリプトをいくつか作ってあったので、その戻り値を使ってオートで家計簿作れたらいいなーという思いによるものです。ハッシュのキーをそのままスプレッドシート内の項目名として使っているので、シンボルではなく文字列をキーとして使ってしまっているのがあまりよろしくないのかなぁとは思うのだが、いつか改善するってーことで、とりあえず動くものを作ることを優先させた。んで、これって結構汎用的に使えそうなスクリプトかもなと思って公開した次第。&lt;/p&gt;

&lt;p&gt;Googleスプレッドシートをいじるのには&lt;code&gt;google-drive-ruby&lt;/code&gt;というGemを使ってます。Githubは&lt;a href=&#34;https://github.com/gimite/google-drive-ruby&#34;&gt;ここ&lt;/a&gt;。&lt;code&gt;def initialize&lt;/code&gt;内の処理は、このGemの初期設定によるものなので、Gemの方のReadme読んでもらえればよいかと。単純な話、GoogleのOAuth API使っているだけの話です。ただ、このコードだと叩くたびにブラウザからAPI使用許可を与えてやって、success codeをコピーしてコマンドラインで入力してやらなくちゃならないっていう手間があって、そこまで省く方法なにかありそうだけどまだ調べてない。あと気になっている点としては、このGemでセルの値を取ると、表示値しか取れないこと。式を入れているセルについては、式を取るか表示値を取るか選べるといいなぁと思ったんだけど、そこまではできないらしい。しかしまぁ、とにかくGoogleスプレッドシートという、APIで叩けるクラウドの表計算ソフトがあるというのは本当に便利なことですね、って感じ。&lt;/p&gt;

&lt;h2 id=&#34;参考:9537427b0e52956dce374263e075553c&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/inokappa/items/2566b21f4b1deac6f95b&#34;&gt;RubyからGoogle SpreadSheet をいじるメモ - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/yumiyon/items/d7c370b3b8582431a3de&#34;&gt;Google DriveのスプレッドシートにRubyでアクセスする方法 - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Ruby基礎学習(10) Mix-in</title>
      <link>http://chroju.github.io/blog/2015/04/24/ruby-study-mix-in/</link>
      <pubDate>Fri, 24 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>http://chroju.github.io/blog/2015/04/24/ruby-study-mix-in/</guid>
      <description>

&lt;p&gt;Mix-inの話と、それに似たもろもろ。他に詳しい記事があるので、これを読んでおけばいいような気はした。&lt;/p&gt;

&lt;h2 id=&#34;参考:71679b93afb0eb3550de4139fb6430a6&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://faultier.blog.jp/archives/1220074.html&#34;&gt;requireとincludeとextendとmodule_function(1) : As Sloth As Possible&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://faultier.blog.jp/archives/1220088.html&#34;&gt;requireとincludeとextendとmodule_function(2) : As Sloth As Possible&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;require:71679b93afb0eb3550de4139fb6430a6&#34;&gt;require&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Kernelモジュールのモジュール関数。&lt;/li&gt;
&lt;li&gt;引数に与えたRubyライブラリを1回ロード、というか実行する。&lt;/li&gt;
&lt;li&gt;使う場面としてはgemだとか自作のライブラリ（クラス）を読み込むときに指定する。&lt;/li&gt;
&lt;li&gt;指定した引数は$LOAD_PATHに探しに行き、カレントディレクトリは含まれないため、パスの指定には少し注意が必要。&lt;/li&gt;
&lt;li&gt;同じファイルを複数回requireしようとしても、1回しか読み込まない。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;load:71679b93afb0eb3550de4139fb6430a6&#34;&gt;load&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Kernelモジュールのモジュール関数。&lt;/li&gt;
&lt;li&gt;requireと同様に外部ライブラリを実行するが、同じファイルを何度でも読み込める。&lt;/li&gt;
&lt;li&gt;requireは拡張子の自動補完を行うが、loadは行わない。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;include:71679b93afb0eb3550de4139fb6430a6&#34;&gt;include&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Moduleクラスのインスタンスメソッド。&lt;/li&gt;
&lt;li&gt;Moduleを引数に取り、メソッドや定数といった対象Moduleの性質を取り込む。&lt;/li&gt;
&lt;li&gt;ArrayやHashがEnumerableの性質を持っているのはincludeしていることによるもの。&lt;/li&gt;
&lt;li&gt;継承とは異なるが、メソッドの探索対象としてはスーパークラスよりincludeされたModuleの方が先になる。&lt;/li&gt;
&lt;li&gt;同じモジュールを複数回読み込もうとしても、2回目以降は無視される。&lt;/li&gt;
&lt;li&gt;Rubyは多重継承を認めていないが、その代わりの機能を果たすという位置付けらしい。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;extend:71679b93afb0eb3550de4139fb6430a6&#34;&gt;extend&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Objectクラスのインスタンスメソッド。&lt;/li&gt;
&lt;li&gt;引数に取ったModuleのメソッドを特異メソッドとして取り込める。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Ruby基礎復習(9) Dirクラス</title>
      <link>http://chroju.github.io/blog/2015/04/14/study-ruby-dir/</link>
      <pubDate>Tue, 14 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>http://chroju.github.io/blog/2015/04/14/study-ruby-dir/</guid>
      <description>&lt;p&gt;『パーフェクトRuby』p.208より。&lt;/p&gt;

&lt;p&gt;Dirクラスは基本としてカレントディレクトリ情報を持っていて、それを元としてディレクトリ操作ができる。従って多くの操作を特異メソッドで行うことができる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Dir.pwd # =&amp;gt; &amp;quot;/Users/chroju&amp;quot;
Dir.chdir(&amp;quot;/tmp&amp;quot;)
Dir.pwd # =&amp;gt; &amp;quot;/tmp&amp;quot;
Dir.home # =&amp;gt; &amp;quot;/Users/chroju&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ディレクトリに含まれるファイルは&lt;code&gt;Dir.entries&lt;/code&gt;で配列として返り、&lt;code&gt;Dir.foreach&lt;/code&gt;でEnumerableとして返る。また&lt;code&gt;Dir.glob&lt;/code&gt;により、パターンにマッチするファイルパスを配列で返すこともできる。&lt;code&gt;Dir.glob&lt;/code&gt;は&lt;code&gt;Dir[]&lt;/code&gt;と同義である。引数のディレクトリが存在するか確認する場合は&lt;code&gt;Dir.exists?&lt;/code&gt;を用いる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Dir.entries(&#39;.&#39;) # =&amp;gt; [&amp;quot;.&amp;quot;, &amp;quot;..&amp;quot;, &amp;quot;bar&amp;quot;, &amp;quot;foo&amp;quot;, &amp;quot;baz&amp;quot;]
Dir.foreach(&#39;.&#39;) {|d|
  p d
} # =&amp;gt; &amp;quot;.&amp;quot;, &amp;quot;..&amp;quot;, &amp;quot;bar&amp;quot;, &amp;quot;foo&amp;quot;, &amp;quot;baz&amp;quot;
Dir.glob(&#39;ba*&#39;) # =&amp;gt; [&amp;quot;bar&amp;quot;, &amp;quot;baz&amp;quot;]
Dir[&#39;ba*&#39;] # =&amp;gt; [&amp;quot;bar&amp;quot;, &amp;quot;baz&amp;quot;]
Dir.exists?(&amp;quot;hoo&amp;quot;) # =&amp;gt; false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ディレクトリの削除、生成等も特異メソッドにて。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Dir.mkdir &#39;foo&#39;, 0755 # パーミッション0755でfooディレクトリを生成
Dir.rmdir &#39;foo&#39; # fooディレクトリを削除するが、対象ディレクトリは空である必要がある
Dir.delete &#39;foo&#39; # Dir.rmdirと同義
Dir.unlink &#39;foo&#39; # Dir.rmdirと同義
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Dir.open&lt;/code&gt;すると、Dirオブジェクトを取得することができ、インスタンスメソッドによる操作が可能になる。Dirオブジェクトは読み込み位置を持っていて、ディレクトリ内のファイル名を1つずつ読み込ませることができる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;dir = Dir.open(&#39;.&#39;)
dir.path # =&amp;gt; &amp;quot;/temp&amp;quot; （現在のファイルパス）
dir.pos # =&amp;gt; 0 （現在の読み込み位置）
dir.pos = 1 # 読み込み位置を移動
dir.read # =&amp;gt; &amp;quot;..&amp;quot;
dir.rewind # 読み込み位置を先頭に戻す
dir.read # =&amp;gt; &amp;quot;.&amp;quot;
dir.each {|f| p f} # =&amp;gt; &amp;quot;.&amp;quot;, &amp;quot;..&amp;quot;, &amp;quot;bar&amp;quot;, &amp;quot;baz&amp;quot;, &amp;quot;foo&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Ruby基礎復習(8) Fileクラス</title>
      <link>http://chroju.github.io/blog/2015/04/10/study-ruby-file-i-o/</link>
      <pubDate>Fri, 10 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>http://chroju.github.io/blog/2015/04/10/study-ruby-file-i-o/</guid>
      <description>&lt;p&gt;『パーフェクトRuby』p.196より。わりと苦手な分野。&lt;/p&gt;

&lt;p&gt;まずはファイルをひらく。&lt;code&gt;#open&lt;/code&gt;して変数に格納してもいいし、ブロックを引き渡して処理させることもできる。後者の場合は処理が終わると自動でクローズしてくれるので、こっちの方が楽っぽい。&lt;code&gt;#read&lt;/code&gt;はファイルの内容全体を読み込む一方、&lt;code&gt;#gets&lt;/code&gt;を使うと1行ずつ読み込むことができる。あるいは&lt;code&gt;#each_line&lt;/code&gt;や&lt;code&gt;#each_char&lt;/code&gt;といったメソッドも。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;file = File.open(&#39;example.txt&#39;)
p file.read # example.txtの内容を表示
file.close

File.open &#39;example.txt&#39; do |file|
  p file.read
end

File.read(&#39;example.txt&#39;)

File.open &#39;example.txt&#39; do |file|
  while line = file.gets
    p line
  end
end

File.open &#39;example.txt&#39; do |file|
  f.each_line do |line|
    p line
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;書き込むときは&lt;code&gt;#open&lt;/code&gt;の第二引数にファイルを開くモードを指定する。デフォルトは&lt;code&gt;&#39;r&#39;&lt;/code&gt;、すなわち読み込みモードで、他は以下の通り。基本は&lt;code&gt;r&lt;/code&gt;が読み込み、&lt;code&gt;w&lt;/code&gt;が書き込み、&lt;code&gt;a&lt;/code&gt;が追記で、&lt;code&gt;+&lt;/code&gt;を付けると読み書き両用モードになる。また&lt;code&gt;b&lt;/code&gt;を後置するとバイナリモードで開かれる。&lt;/p&gt;

&lt;p&gt;| r  | 読み込みモード         |
| r+ | 読み書き両用モード（読み書き位置は先頭から）       |
| w  | 上書き書き込みモード   |
| w+ | 新規作成して読み書き両用モード |
| a  | 追記書き込みモード       |
| a+ | 追記読み書き両用モード（読み込み位置は先頭から、書き込みは追記形式）  |&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;File.open &#39;example.txt&#39;, &#39;w&#39; do |f|
  f.write &#39;hoge&#39;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;もっと単純に&lt;code&gt;#write&lt;/code&gt;メソッドだけでも書き込み可能。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;File.write &#39;example.txt&#39;, &#39;fuga&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先のファイルを開くモードの話の中で「読み込み位置は先頭から」という表現があったが、IOオブジェクトではファイル内の今どこを読み／書きしているかというアクセス位置が存在する。&lt;code&gt;#gets&lt;/code&gt;では1行ずつ読み込みを行ったように、読み／書きを行うことでアクセス位置は進んでいく。先頭まで戻りたい場合は&lt;code&gt;#rewind&lt;/code&gt;を使う。また&lt;code&gt;#seek&lt;/code&gt;メソッドは第二引数に定数で指定した基準位置より、第一引数の整数分アクセス位置を移動させることができる。&lt;code&gt;#pos&lt;/code&gt;は絶対的にアクセス位置を指定して動かせる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;File.open &#39;example.txt&#39; do |f|
  f.puts
  f.rewind # 先頭位置まで戻る

  f.seek 10 # 先頭から10進む
  f.seek -10, IO::SEEK_END # 末尾（SEEK_END）から10戻った位置に移動

  f.pos = 25 # 先頭から25バイト目に移動
  f.pos # =&amp;gt; 25
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;文字のエンコーディングについては、「外部」と「内部」という概念を持つ。外部はファイルのエンコーディング情報であり、内部はRuby上で処理する際のエンコーディング情報。例えばEUC-JPのファイルをutf-8で変換して取り扱い、書き込みはEUC-JPで、といったことができる。エンコーディングの設定には&lt;code&gt;#set_encoding&lt;/code&gt;メソッドを使う。引数を1つだけ取る場合は外部エンコーディングを設定し、2つ取る場合は第一引数が外部、第二引数が内部を設定する。あるいは&lt;code&gt;File#open&lt;/code&gt;するときに、読み書きモードと一緒にエンコーディングも指定することができる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;File.open &#39;example.txt&#39; do |f|
  f.set_encoding(&#39;utf-8&#39;) # 外部エンコーディングをutf-8に設定

  f.set_encoding(&#39;utf-8&#39;, &#39;EUC-JP&#39;) # 外部エンコーディングをutf-8、内部エンコーディングをEUC-JPに設定
  f.set_encoding(&#39;utf-8:EUC-JP&#39;) # 外部エンコーディングをutf-8、内部エンコーディングをEUC-JPに設定
end

File.open &#39;example.txt&#39;, &#39;r:utf-8:EUC-JP&#39; do |f|
  p f.external_encoding # =&amp;gt; &amp;quot;utf-8&amp;quot;
  p f.internal_encoding # =&amp;gt; &amp;quot;EUC-JP&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ファイルのロックには&lt;code&gt;#flock&lt;/code&gt;メソッドを利用する。ロックのモードは&lt;a href=&#34;http://docs.ruby-lang.org/ja/1.9.3/method/File/i/flock.html&#34;&gt;ここに記載の定数&lt;/a&gt;を使って指定するのだが、主に&lt;code&gt;File::LOCK_EX&lt;/code&gt;が排他ロックであることを覚えとけばいいような気も。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;File.open &#39;example.txt&#39;, &#39;w&#39; do |f|
  f.flock File::LOCK_EX
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;その他、ファイル情報取得系のメソッドをつらつらと。これらはファイルオブジェクトから取得するだけではなく、&lt;code&gt;File.atime(filename)&lt;/code&gt;の形で&lt;code&gt;File&lt;/code&gt;クラスのクラスメソッドでも呼び出すことができる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;File.open &#39;example.txt&#39; do |f|
  f.atime # 最終アクセス日時
  f.ctime # 最終変更日時
  f.mtime # 最終更新日時

  f.size # ファイルサイズ

  f.ftype # ファイルタイプ 以下真偽判定メソッドも有り
  f.file?
  f.directory?
  f.symlink?

  f.writable? # =&amp;gt; false
  f.readable? # =&amp;gt; true
  f.executable? # =&amp;gt; false

  f.owned? # =&amp;gt; false (自身がファイル所有者か？)
  f.gid # ファイル所有者のGID
  f.uid # ファイル所有者のUID
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ファイル操作系。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# ファイル名変更、ファイル移動
File.rename &#39;hoge&#39;, &#39;fuga&#39;
File.rename &#39;hoge&#39;, &#39;dir/hoge&#39;

# ファイル削除
File.unlink &#39;hoge&#39;

# シンボリックリンク作成
File.symlink &#39;target&#39;, &#39;link&#39;

# ハードリンク作成
File.link &#39;target&#39;, &#39;link&#39;

# ファイルモード変更
File.chmod 0600, &#39;filename&#39;

# 所有者、グループの変更
File.chown 100, 100, &#39;filename&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ファイルパスに関するもろもろ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# ファイルのあるディレクトリパスの取得
File.dirname(&amp;quot;etc/sample.txt&amp;quot;) # =&amp;gt; &amp;quot;/etc&amp;quot;

# 第一引数に与えたファイルパスに対する、ファイル名の取得。第二引数でsuffix指定。
File.basename(&amp;quot;etc/sample.txt&amp;quot;) # =&amp;gt; &amp;quot;sample.txt&amp;quot;
File.basename(&amp;quot;etc/sample.txt&amp;quot;, &amp;quot;.txt&amp;quot;) # =&amp;gt; &amp;quot;sample&amp;quot;

# 拡張子の取得
File.extname(&amp;quot;etc/sample.txt&amp;quot;) # =&amp;gt; &amp;quot;.txt&amp;quot;

# ファイルパスの連結（引数は可変長）
File.join(&amp;quot;/usr/local&amp;quot;, &amp;quot;bin/ruby&amp;quot;) # =&amp;gt; &amp;quot;/usr/local/bin/ruby&amp;quot;

# ファイルパスからdirnameとbasenameを取得し配列生成
File.split(&amp;quot;/usr/local/bin/ruby&amp;quot;) # =&amp;gt; [&amp;quot;/usr/local/bin&amp;quot;, &amp;quot;ruby&amp;quot;]

# 絶対パスの展開
File.expand_path(&amp;quot;~&amp;quot;) # =&amp;gt; &amp;quot;/home/chroju&amp;quot;
File.expand_path(&amp;quot;filename&amp;quot;, &amp;quot;~&amp;quot;) # =&amp;gt; &amp;quot;/home/chroju/filename&amp;quot;

# absolute_pathでは~を展開しない
File.absolute_path(&amp;quot;~&amp;quot;) # =&amp;gt; &amp;quot;/home/chroju/~&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dirクラスも触れたいのだが、長くなるので一旦ここまで。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Ruby基礎復習(7) Timeクラス</title>
      <link>http://chroju.github.io/blog/2015/04/06/study-ruby-time/</link>
      <pubDate>Mon, 06 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>http://chroju.github.io/blog/2015/04/06/study-ruby-time/</guid>
      <description>

&lt;p&gt;『パーフェクトRuby』p.190より。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Time#now&lt;/code&gt;か&lt;code&gt;Time#new&lt;/code&gt;で現在時刻が取得可能。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;now = Time.now # =&amp;gt; 2015-03-16 23:25:32 +0900
new = Time.new # =&amp;gt; 2015-03-16 23:25:32 +0900

now.zone # =&amp;gt; &amp;quot;JST&amp;quot;
now.getutc # =&amp;gt; 2015-03-16 14:25:32 UTC
now.utc
now.zone # =&amp;gt; &amp;quot;UTC&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;現在時刻以外のTimeオブジェクトを生成するには&lt;code&gt;Time#at&lt;/code&gt;でUNIX秒を引数に指定するか、&lt;code&gt;Time#utc&lt;/code&gt;か&lt;code&gt;Time#local&lt;/code&gt;で直接時刻を指定する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Time.at(0) # =&amp;gt; 1970-01-01 09:00:00 +0900
Time.utc(2015, 1, 1, 2, 30, 40, 100) # =&amp;gt; 2015-01-01 02:30:40 UTC (最後の100はマイクロ秒)
Time.local(2015, 1, 1, 2, 30, 40, 100) # =&amp;gt; 2015-01-01 02:30:40 +0900
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;#to_i&lt;/code&gt;、&lt;code&gt;#to_f&lt;/code&gt;、&lt;code&gt;#to_r&lt;/code&gt;の戻り値はUNIX秒。&lt;code&gt;#to_s&lt;/code&gt;で文字列表現が返る。&lt;code&gt;#to_a&lt;/code&gt;は秒、分、時、日、月、年、曜日、その年の通算日数、夏時間の真偽判定、タイムゾーンの配列を返す。なお、この配列フォーマットを展開して&lt;code&gt;Time#utc&lt;/code&gt;や&lt;code&gt;Time#local&lt;/code&gt;の引数として与えることもできる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;now.to_i # =&amp;gt; 1426515932
now.to_f # =&amp;gt; 1426515932.978824
now.to_r # =&amp;gt; (178314491622353/125000)
now.to_s # =&amp;gt; &amp;quot;2015-03-16 23:25:32 +0900&amp;quot;
now.to_a # =&amp;gt; [32, 25, 23, 16, 3, 2015, 1, 75, false, &amp;quot;JST&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;#to_s&lt;/code&gt;の戻り値は上記フォーマットの固定だが、任意のフォーマットで文字列表現を得たい場合は&lt;code&gt;#strftime&lt;/code&gt;を使う。使えるフォーマット文字列は&lt;a href=&#34;http://docs.ruby-lang.org/ja/1.9.3/class/Time.html&#34;&gt;公式ドキュメント&lt;/a&gt;参照で。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;now.strftime(&amp;quot;今日は%Y年%m月%d日、今は%H時%M分を%S秒過ぎたところです。&amp;quot;) # =&amp;gt; &amp;quot;今日は2015年3月16日、今は23時25分を32秒過ぎたところです。&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;逆に文字列表現からTimeオブジェクトを得たい場合は&lt;code&gt;#strptime&lt;/code&gt;が使える。&lt;/p&gt;

&lt;h2 id=&#34;参照:255aa2049f81c2f1b4d0b6712e8d9bff&#34;&gt;参照&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/riocampos/items/de59263ac4e991a98f49&#34;&gt;Ruby - 日本語表記の日時をTimeオブジェクトに変換（Time.strptimeメソッド） - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;その他もろもろの出力。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;now.year # =&amp;gt; 2015
now.month # =&amp;gt; 3
now.day # =&amp;gt; 16
now.hour # =&amp;gt; 23
now.min # =&amp;gt; 25
now.sec # =&amp;gt; 32
now.nsec # =&amp;gt; 978824000 (ナノ秒)
now.wday # =&amp;gt; 1 (曜日は日曜を0としてカウント)
now.yday # =&amp;gt; 75 (年初からの日数)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;曜日やサマータイム(DST)については疑問符のメソッドで真偽判定できる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;now.dst? # =&amp;gt; false
now.sunday? # =&amp;gt; false
now.monday? # =&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Timeオブジェクト同士の比較についてはナノ秒まで判定されるので、そのあたりに注意とのこと。以下のようなことがあり得る。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;now = Time.now # =&amp;gt; 2015-03-16 23:25:32 +0900
new = Time.new # =&amp;gt; 2015-03-16 23:25:32 +0900

now == new # =&amp;gt; false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;整数を与えることによる加算減算は秒として取り扱われる。Timeオブジェクト同士の減算も可能。その場合は差分の秒数が浮動小数点数で返る。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;now = Time.now # =&amp;gt; 2015-03-16 23:25:32 +0900

now + 1 # =&amp;gt; 2015-03-16 23:25:33 +0900
now - 1 # =&amp;gt; 2015-03-16 23:25:31 +0900
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なお時間や日時を扱うクラスには他に&lt;code&gt;Date&lt;/code&gt;や&lt;code&gt;DateTime&lt;/code&gt;もあるが、組み込みのライブラリはこの&lt;code&gt;Time&lt;/code&gt;だけ。どれを使えばええんや？ってのは、探してみたら大変詳しいQiitaを見つけたんでそっちに譲ります。&lt;/p&gt;

&lt;h2 id=&#34;参考:255aa2049f81c2f1b4d0b6712e8d9bff&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/jnchito/items/cae89ee43c30f5d6fa2c&#34;&gt;RubyとRailsにおけるTime, Date, DateTime, TimeWithZoneの違い - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Ruby基礎復習(6) Hash</title>
      <link>http://chroju.github.io/blog/2015/04/05/study-ruby-hash/</link>
      <pubDate>Sun, 05 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>http://chroju.github.io/blog/2015/04/05/study-ruby-hash/</guid>
      <description>&lt;p&gt;『パーフェクトRuby』p.179より。&lt;/p&gt;

&lt;p&gt;まず基本的なとこで。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;hash = {hoge: 1, fuga: 2}

hash.each do |key, val|
  p &amp;quot;#{key}: #{val}&amp;quot;
end # =&amp;gt; &amp;quot;hoge: 1&amp;quot;, &amp;quot;fuga: 2&amp;quot;

hash.each_key do |key|
  p key
end # =&amp;gt; &amp;quot;hoge&amp;quot;, &amp;quot;fuga&amp;quot;

hash.each_value do |val|
  p val
end # =&amp;gt; &amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;

hash[:hoge] = 3
p hash # =&amp;gt; {hoge: 3, fuga: 2}
hash[:piyo] = 4
p hash # =&amp;gt; {hoge: 3, fuga: 2, piyo: 4}

hash.delete(:piyo)
hash # =&amp;gt; {hoge: 3, fuga: 2}

hash.empty? # =&amp;gt; false
hash.length # =&amp;gt; 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ハッシュの生成は&lt;code&gt;Hash[]&lt;/code&gt;により偶数個の引数から行うこともできる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ary = [&amp;quot;hoge&amp;quot;, 1, &amp;quot;fuga&amp;quot;, 2]
Hash[*ary] # =&amp;gt; {hoge: 1, fuga: 2}

ary = [[&amp;quot;hoge&amp;quot;, 1], [&amp;quot;fuga&amp;quot;, 2]]
Hash[ary] # =&amp;gt; {hoge: 1, fuga: 2}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Arrayクラスと同様の&lt;code&gt;#select&lt;/code&gt;、&lt;code&gt;#reject&lt;/code&gt;、&lt;code&gt;#keep_if&lt;/code&gt;、&lt;code&gt;#delete_if&lt;/code&gt;操作が可能。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;hash = {hoge: 1, fuga: 2, piyo: 3}

hash.select {|key, val| val.even? } # =&amp;gt; {fuga: 2}
p hash # =&amp;gt; {hoge: 1, fuga: 2, piyo: 3}
hash.select! {|key, val| val.even? } # =&amp;gt; {fuga: 2}
p hash # =&amp;gt; {fuga: 2}

hash = {hoge: 1, fuga: 2, piyo: 3}

hash.reject {|key, val| val.even? } # =&amp;gt; {hoge: 1, piyo: 3}
p hash # =&amp;gt; {hoge: 1, fuga: 2, piyo: 3}
hash.reject! {|key, val| val.even? } # =&amp;gt; {hoge: 1, piyo: 3}
p hash # =&amp;gt; {hoge: 1, piyo: 3}

hash.select! {|key, val| val.even? } # =&amp;gt; nil
hash.keep_if {|key, val| val.even? } # =&amp;gt; {hoge: 1, piyo: 3}
hash.reject! {|key, val| val.even? } # =&amp;gt; nil
hash.delete_if {|key, val| val.even? } # =&amp;gt; {hoge: 1, piyo: 3}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hashの統合は&lt;code&gt;Hash#merge&lt;/code&gt;を用いる。キーが重複する場合は、引数で渡されたハッシュの値で上書きされる。ブロックを引き渡している場合は、キー重複時の処理をブロックの中で定義できる。破壊的操作である&lt;code&gt;Hash#merge!&lt;/code&gt;は&lt;code&gt;Hash#update&lt;/code&gt;とも書くことが出来る。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;a = {hoge: 1, fuga: 2}
b = {hoge: 3, piyo: 4}
a.merge(b) # =&amp;gt; {hoge: 3, fuga: 2, piyo: 4}
p a # =&amp;gt; {hoge: 1, fuga: 2}

a.merge!(b) {|key, a_val, b_val|
  a_val + b_val
} # =&amp;gt; {hoge: 4, fuga: 2, piyo: 4}
p a # =&amp;gt; {hoge: 4, fuga: 2, piyo: 4}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;キーと値の取得に関して。特に特定キーの存在確認については、&lt;code&gt;Hash#has_key?&lt;/code&gt;を用いる。通常の&lt;code&gt;Hash[]&lt;/code&gt;による呼び出しだと、値が存在しない場合でもnilが返ってきてしまい、値がnilなのか、それとも存在していないのか区別がつかないため。あるいは&lt;code&gt;Hash#fetch&lt;/code&gt;を用いれば、値が存在しない場合の返り値を指定できる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;hash = {hoge: 1, fuga: 2, piyo: 3, hogehoge: nil}

hash.keys # =&amp;gt; [:hoge, :fuga, :piyo]
hash.key(2) # =&amp;gt; :fuga

hash.values # =&amp;gt; [1, 2, 3]
hash.values_at(:fuga) # =&amp;gt; [2]
hash.values_at(:fuga, :piyo) # =&amp;gt; [2, 3]

hash[:hogehoge] # =&amp;gt; nil
hash[:foo] # =&amp;gt; nil
hash.has_key?(:foo) # =&amp;gt; false
# 以下すべてhas_key?と同義
hash.member?(:foo)
hash.include?(:foo)
hash.key?(:foo)

hash.fetch(:foo) # =&amp;gt; nil
hash.fetch(:foo, &amp;quot;error&amp;quot;) # =&amp;gt; &amp;quot;error&amp;quot;
hash.fetch(:foo){|key| &amp;quot;#{key} not exists&amp;quot;} # =&amp;gt; &amp;quot;foo not exists&amp;quot;

hash.has_value?(3) # =&amp;gt; true
hash.value?(3) # =&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hashにはデフォルト値の概念があり、&lt;code&gt;Hash#new&lt;/code&gt;の引数に与えた値が、存在しないキーを参照したときの返り値となる（デフォルトはnil）。ここで指定した値はすべて同一オブジェクトであり、破壊的操作をする場合などは注意が必要。また&lt;code&gt;Hash#default=&lt;/code&gt;や&lt;code&gt;Hash#default_proc=&lt;/code&gt;により、既存のHashオブジェクトに対してもデフォルト値の変更が可能。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;hash = Hash.new(&amp;quot;null&amp;quot;)
hash[:foo] # =&amp;gt; &amp;quot;null&amp;quot;

hash.default = &amp;quot;undefined&amp;quot;
hash[:foo] # =&amp;gt; &amp;quot;undefined&amp;quot;
default = hash.default
default.reverse!
hash[:foo] # =&amp;gt; &amp;quot;denifednu&amp;quot;

hash.default_proc = -&amp;gt;(hash, key) {&amp;quot;Key: #{key} not exists&amp;quot;}
hash[:foo] # =&amp;gt; &amp;quot;Key: foo not exists&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ハッシュ変換系のメソッド。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;hash = {hoge: 1, fuga: 2}

hash.invert # =&amp;gt; {1: hoge, 2: fuga}
hash.to_a # =&amp;gt; [[:hoge, 1], [:fuga, 2]]
hash.sort # =&amp;gt; [[:fuga, 2], [:hoge, 1]]
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Ruby基礎復習(5) 配列(Array)</title>
      <link>http://chroju.github.io/blog/2015/03/18/study-ruby-array/</link>
      <pubDate>Wed, 18 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>http://chroju.github.io/blog/2015/03/18/study-ruby-array/</guid>
      <description>&lt;p&gt;『パーフェクトRuby』p.171より。&lt;/p&gt;

&lt;p&gt;まずは配列の生成をいくつか。&lt;code&gt;#new(a,b)&lt;/code&gt;で生成したとき、各要素は同じオブジェクトとなるので注意。またブロックで受け取ると、インデックスを引数としてブロック内の処理を実行した結果が値となる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;a1 = Array.new(3,1) # =&amp;gt; [1, 1, 1]
a2 = Array.new(3, &amp;quot;hoge&amp;quot;) # =&amp;gt; [&amp;quot;hoge&amp;quot;, &amp;quot;hoge&amp;quot;, &amp;quot;hoge&amp;quot;]
a3 = [&amp;quot;hoge&amp;quot;, &amp;quot;fuga&amp;quot;, &amp;quot;piyo&amp;quot;] # =&amp;gt; [&amp;quot;hoge&amp;quot;, &amp;quot;fuga&amp;quot;, &amp;quot;piyo&amp;quot;]
a4 = Array.new(3) {|i| i * 5} # =&amp;gt; [0, 5, 10]

a2[0] &amp;lt;&amp;lt; &amp;quot;fuga&amp;quot;
p a2 # =&amp;gt; [&amp;quot;hogefuga&amp;quot;, &amp;quot;hogefuga&amp;quot;, &amp;quot;hogefuga&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;基本的な操作系メソッド。演算子メソッドは直感的でほんといいなーと思う。なお、&lt;code&gt;#&amp;lt;&amp;lt;&lt;/code&gt;は&lt;code&gt;#concat&lt;/code&gt;と同義。&lt;code&gt;#==&lt;/code&gt;と&lt;code&gt;#eql?&lt;/code&gt;も同義。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;array = [&amp;quot;hoge&amp;quot;, &amp;quot;fuga&amp;quot;, &amp;quot;piyo&amp;quot;]

array.length # =&amp;gt; 3
array.size # =&amp;gt; 3
array.empty? # =&amp;gt; false
array.include?(&amp;quot;fuga&amp;quot;) # =&amp;gt; true

p array * 3 # =&amp;gt; [&amp;quot;hoge&amp;quot;, &amp;quot;fuga&amp;quot;, &amp;quot;piyo&amp;quot;, &amp;quot;hoge&amp;quot;, &amp;quot;fuga&amp;quot;, &amp;quot;piyo&amp;quot;, &amp;quot;hoge&amp;quot;, &amp;quot;fuga&amp;quot;, &amp;quot;piyo&amp;quot;]
p array + [1, 2] # =&amp;gt; [&amp;quot;hoge&amp;quot;, &amp;quot;fuga&amp;quot;, &amp;quot;piyo&amp;quot;, 1, 2]
p array - [&amp;quot;hoge&amp;quot;, &amp;quot;piyo&amp;quot;] # =&amp;gt; [&amp;quot;fuga&amp;quot;]
p array &amp;amp; [&amp;quot;piyo&amp;quot;] # =&amp;gt; [&amp;quot;piyo&amp;quot;]
array &amp;lt;&amp;lt; &amp;quot;hogehoge&amp;quot; # =&amp;gt; [&amp;quot;hoge&amp;quot;, &amp;quot;fuga&amp;quot;, &amp;quot;piyo&amp;quot;, &amp;quot;hogehoge&amp;quot;]
array2 = [&amp;quot;hoge&amp;quot;, &amp;quot;fuga&amp;quot;, &amp;quot;piyo&amp;quot;]
array3 = [&amp;quot;hoge&amp;quot;, &amp;quot;fuga&amp;quot;, &amp;quot;piyo&amp;quot;, &amp;quot;hogehoge&amp;quot;]
array == array2 # =&amp;gt; false
array == array3 # =&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要素の取り出し。&lt;code&gt;#[a, b]&lt;/code&gt;が添字aから長さbの配列を取り出すのに対し、&lt;code&gt;#values_at(a, b)&lt;/code&gt;が添字a, bの要素を取り出して配列を作る、という点が異なるのが注意かも。&lt;/p&gt;

&lt;p&gt;また範囲外の添字を指定したときの振る舞いだが、&lt;code&gt;#[]&lt;/code&gt;がnilを返すのに対し、第一引数のみの&lt;code&gt;#fetch&lt;/code&gt;はIndexErrorを返す。&lt;code&gt;#fetch&lt;/code&gt;に第二引数を指定すると、範囲外を呼び出したときに第二引数を返すようになる。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;#sample&lt;/code&gt;はランダム抽出。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;array = (1..5).to_a

array[1] # =&amp;gt; 2
array[-1] # =&amp;gt; 5
array[1, 3] # =&amp;gt; [2, 3, 4]
array[2..4] # =&amp;gt; [3, 4, 5]

array.values_at(3) # =&amp;gt; 4
array.values_at(0, 3, 4) # =&amp;gt; [1, 4, 5]

array.fetch(5) # =&amp;gt; IndexError
array[5] # =&amp;gt; nil
array.fetch(5, &amp;quot;error&amp;quot;) # =&amp;gt; &amp;quot;error&amp;quot;

array.first # =&amp;gt; 1
array.last # =&amp;gt; 5
array.last(2) # =&amp;gt; [4, 5]

array.sample # =&amp;gt; 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要素の追加削除。添字を使って普通に要素の入れ替えはできるのだが、面白いのはレンジにない添字を指定してもOutOfBounds扱いにはならず、足りない箇所はnilを埋めて補完してくれること。&lt;code&gt;#insert&lt;/code&gt;は第一引数をインデックスとする要素の直前に、第二引数以降の要素を挿入する。あと&lt;code&gt;#fill&lt;/code&gt;は全要素を同じオブジェクトで埋め込む。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;array = (1..5).to_a

array[1] = 0 # =&amp;gt; [1, 0, 3, 4, 5]
array[8] = 10 # =&amp;gt; [1, 0, 3, 4, 5, nil, nil, nil, 10]

array.push(3) # =&amp;gt; [1, 0, 3, 4, 5, nil, nil, nil, 10, 3]
array.pop # =&amp;gt; 3
p array # =&amp;gt; [1, 0, 3, 4, 5, nil, nil, nil, 10]

array.shift # =&amp;gt; [0, 3, 4, 5, nil, nil, nil, 10]
array.unshift(1) # =&amp;gt; [1, 0, 3, 4, 5, nil, nil, nil, 10]

array.insert(2, &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;) # =&amp;gt; [1, 0, &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, 3, 4, 5, nil, nil, nil, 10]

array.fill(0) # =&amp;gt; [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
array.clear # =&amp;gt; []
p array # =&amp;gt; []
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要素の選択周り。ブロック内の処理でtrueとなった要素について、&lt;code&gt;#select&lt;/code&gt;では抽出、&lt;code&gt;#reject&lt;/code&gt;では削除を行う。いずれも破壊的／非破壊的の別があり。&lt;code&gt;#keep_if&lt;/code&gt;は&lt;code&gt;#select!&lt;/code&gt;と同様の動作をするが、削除する要素がなかった場合に&lt;code&gt;#select!&lt;/code&gt;がnilを返す一方で、&lt;code&gt;#keep_if&lt;/code&gt;がレシーバをそのまま返すという違いがある。&lt;code&gt;#delete_if&lt;/code&gt;についても同様。ブロック内での評価ではなく、単純に特定の値と等しい要素を削除したい場合は&lt;code&gt;#delete&lt;/code&gt;が使える。これは破壊的。&lt;code&gt;#delete_at&lt;/code&gt;は添字による指定で削除する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;array = (1..5).to_a
array.select {|i| i.even? } # =&amp;gt; [2, 4]
p array # =&amp;gt; [1, 2, 3, 4, 5]
array.select! {|i| i.even? } # =&amp;gt; [2, 4]
p array # =&amp;gt; [2, 4]

array = (1..5).to_a
array.reject {|i| i.even? } # =&amp;gt; [1, 3, 5]
p array # =&amp;gt; [1, 2, 3, 4, 5]
array.reject! {|i| i.even? } # =&amp;gt; [1, 3, 5]
p array # =&amp;gt; [1, 3, 5]

array = [2, 4, 6]
array.select! {|i| i.even? } # =&amp;gt; nil
array.keep_if {|i| i.even? } # =&amp;gt; [2, 4, 6]
array.reject! {|i| i.odd? } # =&amp;gt; nil
array.delete_if {|i| i.odd? } # =&amp;gt; [2, 4, 6]

array.delete 4 # =&amp;gt; [2, 6]
array.delete_at 1 # =&amp;gt; [2]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同様に要素の切り出しでは&lt;code&gt;#slice&lt;/code&gt;というメソッドもあるが、引数の与え方で動作が変わってくる。Integerの引数1つを与えると、そのインデックスにある要素を返す。範囲外の場合はnilが返る。Integerの引数2つでは、第一引数のインデックスより、第二引数の個数分要素を切り出して返す。Rangeを引数とすると、その範囲のインデックスにあたる要素を返す。&lt;/p&gt;

&lt;p&gt;またいずれの場合でも&lt;code&gt;!&lt;/code&gt;による破壊的メソッドがあるが、ここでは戻り値となる要素が配列より削除される。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;a = [2, 4, 6, 9]
a.slice(1) # =&amp;gt; 4
a.slice(1, 4) # =&amp;gt; [4, 6, 9]
a.slice(1..2) # =&amp;gt; [4, 6]

a.slice(2) # =&amp;gt; 6
p a # =&amp;gt; [2, 4, 9]
a.slice(0..1) # =&amp;gt; [2, 4]
p a # =&amp;gt; [9]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;整形。&lt;code&gt;#compact&lt;/code&gt;はnilを要素から除外する。&lt;code&gt;#uniq&lt;/code&gt;は重複した要素を除外。&lt;code&gt;#reverse&lt;/code&gt;は要素の順序を逆にする。&lt;code&gt;#flatten&lt;/code&gt;は多次元配列を1次元に変換する。いずれも&lt;code&gt;!&lt;/code&gt;を付けることで破壊的になる。また&lt;code&gt;#sort!&lt;/code&gt;や&lt;code&gt;#map!&lt;/code&gt;といった破壊的要素を使うことで、実行結果により自身を更新できる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;a = [5, 3, nil, 3, nil, 9, 1, [4, 3]]
a.compact! # =&amp;gt; [5, 3, 3, 9, 1, [4, 3]]
a.uniq! # =&amp;gt; [5, 3, 9, 1, [4, 3]]
a.reverse! # =&amp;gt; [[4, 3], 1, 9, 3, 5]
a.flatten! # =&amp;gt; [4, 3, 1, 9, 3, 5]
a.sort! # =&amp;gt; [1, 3, 3, 4, 5, 7, 9]
a.map! {|i| i * 2 } # =&amp;gt; [2, 6, 6, 8, 10, 14, 18]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;複製。&lt;code&gt;#dup&lt;/code&gt;は内容のみを複製する（浅いコピー）のに対し、&lt;code&gt;#clone&lt;/code&gt;はfrozen等の情報も複製する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;a = [1, 2, 3].freeze
a[0] = 5 # =&amp;gt; RuntimeError

b = a.dup
b[0] = 5 # =&amp;gt; [5, 2, 3]

c = a.clone
c[0] = 5 # =&amp;gt; RuntimeError
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;若干変わったものを最後にいくつか。&lt;code&gt;#transpose&lt;/code&gt;は多次元配列を行列とみなして、行と列の入れ替えを行う。破壊的メソッドはない。&lt;code&gt;#bsearch&lt;/code&gt;はソートされている配列に対して使用し、二分探索で最初に見つかった要素を返す。&lt;code&gt;#join&lt;/code&gt;は各要素を連結した値を返す。引数にセパレータを渡すことも可。&lt;code&gt;#shuffle&lt;/code&gt;は配列をランダムにシャッフルする。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;a = [[1, 2], [3, 4]]
a.transpose # =&amp;gt; [[1, 3], [2, 4]]

a = [0, 3, 5, 7, 9]
a.bsearch {|i| i &amp;gt; 2 } # =&amp;gt; 3

a.join # =&amp;gt; &amp;quot;03579&amp;quot;
a.join(&amp;quot;-&amp;quot;) # =&amp;gt; &amp;quot;0-3-5-7-9&amp;quot;

a.shuffle!
p a # =&amp;gt; [5, 9, 0, 3, 7]
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Ruby基礎復習(4) EnumerableとComparable</title>
      <link>http://chroju.github.io/blog/2015/03/17/study-ruby-enumerable-comparable/</link>
      <pubDate>Tue, 17 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>http://chroju.github.io/blog/2015/03/17/study-ruby-enumerable-comparable/</guid>
      <description>

&lt;p&gt;『パーフェクトRuby』p.164より。&lt;/p&gt;

&lt;p&gt;一部組み込みクラスは、EnumerableやComparableというモジュールがincludeされている。前者は聞き慣れない英単語だが、&amp;rdquo;can be counted&amp;rdquo;の意味らしく、HashやArrayといった一定の集合を表すクラスにincludeされていて、繰り返し処理や要素抽出に関するメソッドを実装する。Comparableはその名の通り比較演算、具体的には&lt;code&gt;#&amp;lt;=&amp;gt;&lt;/code&gt;の実装であり、NumericやStringにincludeされているらしい。&lt;/p&gt;

&lt;p&gt;特に実装されるメソッド数が多いので、Enumerableについてじっくり見てみたい。&lt;/p&gt;

&lt;h2 id=&#34;enumerable:9699dda966075be7140093fc44402c80&#34;&gt;Enumerable&lt;/h2&gt;

&lt;p&gt;まず繰り返し系。これだけでもかなり。。&lt;code&gt;#each_cons&lt;/code&gt;のconsって何の意味ですかね。他はだいたい字義からイメージできる動作をしてくれる。あと&lt;code&gt;#each_with_object&lt;/code&gt;がいまいち飲み込めてない。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;(1..4).each_cons 2 do |a,b|
  p [a,b]
end # =&amp;gt; [1,2] [2,3] [3,4]

(1..4).each_slice 2 do |a,b|
  p [a,b]
end # =&amp;gt; [1,2] [3,4]

%(hoge fuga piyo).each_with_index do |value, index|
  p &amp;quot;#{index}: #{value}&amp;quot;
end # =&amp;gt; 0: hoge 1: fuga 2: piyo

(1..4).each_with_object([]) {|i, result| result &amp;lt;&amp;lt; i*2} # =&amp;gt; [2,4,6,8]

(1..4).reverse_each do |i|
  p i
end # =&amp;gt; 4,3,2,1

(1..4).cycle {|i| p i} # =&amp;gt; 1,2,3,4,1,2... 以下、無限ループ
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;各要素の評価には&lt;code&gt;#map&lt;/code&gt;と&lt;code&gt;#collect&lt;/code&gt;。いずれも同じ動作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;(1..4).map {|i| i * 3} # =&amp;gt; [3, 6, 9, 12]
(1..4).collect {|i| i * 3} # =&amp;gt; [3, 6, 9, 12]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;判定系。&lt;code&gt;#member?&lt;/code&gt;と&lt;code&gt;include?&lt;/code&gt;は同義。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;[1,2,3].all? {|i| i &amp;gt; 1} # =&amp;gt; false
[1,2,3].any? {|i| i &amp;gt; 1} # =&amp;gt; true
[1,2,3].none? {|i| i &amp;gt; 3} # =&amp;gt; true
[1,2,3].one? {|i| i &amp;gt; 1} # =&amp;gt; false

%w(hoge fuga piyo).member? &amp;quot;fuga&amp;quot; # =&amp;gt; true
%w(hoge fuga piyo).include? &amp;quot;fuga&amp;quot; # =&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;抽出系。覚えやすいことにgrepがある。&lt;code&gt;#detect&lt;/code&gt;は条件に当てはまる最初の要素だけ、&lt;code&gt;#select&lt;/code&gt;はすべてを抽出する。&lt;code&gt;#find_all&lt;/code&gt;は&lt;code&gt;#select&lt;/code&gt;と同義。&lt;code&gt;#reject&lt;/code&gt;は&lt;code&gt;#select&lt;/code&gt;といわば「逆」の動きをする。&lt;code&gt;#take&lt;/code&gt;と&lt;code&gt;#drop&lt;/code&gt;は要素数を指定して先頭から要素抽出orスキップする。あとは語義通りのメソッドがいくつか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;%w(hoge fuga piyo).grep(/o/i) # =&amp;gt; &amp;quot;hoge&amp;quot;, &amp;quot;piyo&amp;quot;
[1,2,&amp;quot;hoge&amp;quot;].grep(String) # =&amp;gt; &amp;quot;hoge&amp;quot;

[1,2,3,4].detect {|i| i.even?} # =&amp;gt; 2
[1,2,3,4].select {|i| i.even?} # =&amp;gt; 2, 4
[1,2,3,4].find_all {|i| i.even?} # =&amp;gt; 2, 4
[1,2,3,4].reject {|i| i.even?} # =&amp;gt; 1, 3
[1,2,3,4].find_index {|i| i.even?} # =&amp;gt; 1

(1..10).take 3 # =&amp;gt; [1,2,3]
(1..10).drop 3 # =&amp;gt; [4,5,6,7,8,9,10]

(1..10).take_while {|i| i &amp;lt; 3} # =&amp;gt; [1,2]
(1..10).drop_while {|i| i &amp;lt; 3} # =&amp;gt; [3,4,5,6,7,8,9,10]

(1..10).max # =&amp;gt; 10
%(aaa bbbb ccccc).max_by {|s| s.length} # =&amp;gt; &amp;quot;ccccc&amp;quot;
(1..10).min # =&amp;gt; 1
%(aaa bbbb ccccc).min_by {|s| s.length} # =&amp;gt; &amp;quot;aaa&amp;quot;
(1..10).minmax # =&amp;gt; [1,10]
%(aaa bbbb ccccc).minmax_by {|s| s.length} # =&amp;gt; [&amp;quot;aaa&amp;quot;, &amp;quot;ccccc&amp;quot;]

(1..10).first # =&amp;gt; 1
(1..10).count # =&amp;gt; 10
(1..10).count(2) # =&amp;gt; 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;#inject&lt;/code&gt;を使うと全要素を総計するような処理ができる。これを「畳み込み演算」と呼ぶらしい。引数2つを必要とするブロックを受け取り、第一引数が直前のループでの演算結果を持ち、第二引数がその回のループでの要素を取る。あるいはブロックを取らず、&lt;code&gt;#inject&lt;/code&gt;の引数にシンボルでメソッド名を渡すことで、全要素に対してそのメソッドを適用した結果を得られる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;(1..5).inject {|result, i| result + i} # =&amp;gt; 15
(1..5).inject(10) {|result, i| result + i} # =&amp;gt; 25
(1..5).inject(:+) # =&amp;gt; 15
(1..5).inject(:*) # =&amp;gt; 120
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;グルーピング。&lt;code&gt;#group_by&lt;/code&gt;はブロックで評価した戻り値をキーとしたハッシュに要素をグルーピングしてくれる。&lt;code&gt;#partition&lt;/code&gt;はブロックで評価した真偽値を元に配列でグルーピング。後者の方が使い勝手は良さそうではある。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;(1..6).group_by {|i| i % 3 } # =&amp;gt; {0=&amp;gt;[3,6], 1=&amp;gt;[1,4], 2=&amp;gt;[2,5]}
(1..6).partition {|i| i.even?} # =&amp;gt; [[1,3,5], [2,4,6]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一番意味がわからない&lt;code&gt;#zip&lt;/code&gt;。selfと引数の配列で、同じ添字にあたる要素を使って新しい配列を生成する。どう使うんだろうこれ。。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;(1..3).zip([4,5,6], [7,8,9]) # =&amp;gt; [1,4,7], [2,5,8], [3,6,9]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;comparableとソート:9699dda966075be7140093fc44402c80&#34;&gt;Comparableとソート&lt;/h2&gt;

&lt;p&gt;個人的に苦手なのがこの宇宙船演算子とソート周り。まず大前提として、宇宙船演算子はレシーバと引数を比較し、レシーバが大きければ1、小さければ-1、同値であれば0を返す。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;1 &amp;lt;=&amp;gt; 2 # =&amp;gt; -1
1 &amp;lt;=&amp;gt; 0 # =&amp;gt; 1
1 &amp;lt;=&amp;gt; 1 # =&amp;gt; 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Comparableモジュールをincludeしたクラスで&lt;code&gt;#&amp;lt;=&amp;gt;&lt;/code&gt;を定義すると、各種演算子による比較のルールを定めることができる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Person
  include Comparable
  attr_accessor :age

  def initialize(age)
    self.age = age
  end

  def &amp;lt;=&amp;gt;(other)
    age &amp;lt;=&amp;gt; other.age
  end
end

taro = Person.new(21)
hanako = Person.new(32)

taro &amp;gt; hanako # =&amp;gt; true
taro == hanako # =&amp;gt; false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で、Enumerableの&lt;code&gt;#sort&lt;/code&gt;は要素を宇宙船演算子で比較して結果が正になるよう並び替えていく。要は昇順がデフォルト。ブロックに引き渡すこともでき、ここで任意の比較方法を定義してソートすることもできる。&lt;code&gt;#sort_by&lt;/code&gt;を使えば宇宙船演算子を使わず、指定のメソッドを使って昇順に並び替えてくれる。メソッド呼び出し回数が&lt;code&gt;#sort_by&lt;/code&gt;だと1回で済むので、実行速度の面で差が出る可能性がある。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;takeshi = Person.new(25)
people = [hanako, taro, takeshi]
people.sort # =&amp;gt; [taro, takeshi, hanako]
people.sort {|a,b| b &amp;lt;=&amp;gt; a} # =&amp;gt; [hanako, takeshi, taro]
people.sort_by {|person| person.age} # =&amp;gt; [taro, takeshi, hanako]
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;なお、意図的に飛ばしてしまったのだが、あと触れてないEnumerableのメソッドとして&lt;code&gt;#chunk&lt;/code&gt;周りがある。ちょっと飲み込みきれてないのでまた次回。&lt;/p&gt;

&lt;h2 id=&#34;参考:9699dda966075be7140093fc44402c80&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://jutememo.blogspot.jp/2008/03/ruby-2-enumerable.html&#34;&gt;Ruby のイテレータ (2) – Enumerable と Comparable モジュール | すぐに忘れる脳みそのためのメモ&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Ruby基礎復習(3) Numericクラス</title>
      <link>http://chroju.github.io/blog/2015/03/16/study-ruby-numeric/</link>
      <pubDate>Mon, 16 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>http://chroju.github.io/blog/2015/03/16/study-ruby-numeric/</guid>
      <description>

&lt;p&gt;パーフェクトRuby p.144より。&lt;/p&gt;

&lt;p&gt;判定系メソッド、&lt;code&gt;#nonzero&lt;/code&gt;が&lt;code&gt;#zero&lt;/code&gt;の真逆の動きではなくてちょっと混乱しそう。あと&lt;code&gt;#integer?&lt;/code&gt;はあるけど&lt;code&gt;#float?&lt;/code&gt;はないとか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;0.zero? # =&amp;gt; true
3.zero? # =&amp;gt; false
0.nonzero? # =&amp;gt; nil
1.nonzero? # =&amp;gt; 1

1.integer? # =&amp;gt; true
1.real? # =&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;演算子系の話は割愛するが、宇宙船演算子だけ注意しとく。右辺（引数）の方が大きければ負。左辺（レシーバ）が大きければ正。&lt;code&gt;#sort&lt;/code&gt;ではブロック内の戻り値が負の場合は2要素をそのまま、正の場合は逆順にして返してくる。宇宙船演算子を利用して昇順or降順に並べ替えることができる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;1 &amp;lt;=&amp;gt; 2 # =&amp;gt; -1
2 &amp;lt;=&amp;gt; 1 # =&amp;gt; 1
1 &amp;lt;=&amp;gt; 1 # =&amp;gt; 0

%w(aaaa aa aaa).sort { |a,b|
  a.length &amp;lt;=&amp;gt; b.length
} # =&amp;gt; [&amp;quot;aa&amp;quot;, &amp;quot;aaa&amp;quot;, &amp;quot;aaaa&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;丸め。&lt;code&gt;#round&lt;/code&gt;が四捨五入。&lt;code&gt;#ceil&lt;/code&gt;で切り上げ。&lt;code&gt;#floor&lt;/code&gt;で切り捨て。馴染みのない英単語で覚えにくい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;1.4.round # =&amp;gt; 1
1.4.ceil # =&amp;gt; 2
1.4.floor # =&amp;gt; 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;#step&lt;/code&gt;で、第一引数に与えられた上限数値に達するまで、レシーバに第二引数の数値を足し合わせていく繰り返し処理がつくれる。第二引数のデフォルトは1。整数であれば&lt;code&gt;#upto&lt;/code&gt;と&lt;code&gt;#downto&lt;/code&gt;で1ずつ加算、減算させていくことも可能。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;2.step 4 do |i|
  puts i
end # &amp;quot;2&amp;quot;,&amp;quot;3&amp;quot;,&amp;quot;4&amp;quot;

2.step 3, 0.3 do |num|
  puts num
end # &amp;quot;2.0&amp;quot;,&amp;quot;2.3&amp;quot;,&amp;quot;2.6&amp;quot;,&amp;quot;2.9&amp;quot;

2.upto 5 do |i|
  puts i
end # 2,3,4,5

4.downto 2 do |i|
  puts i
end # 4,3,2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;整数:3474e642b2d5b6a8e3b2c1120e2a383c&#34;&gt;整数&lt;/h2&gt;

&lt;p&gt;Integerクラスは絶対値の大きさによりFixnumサブクラスとBignumサブクラスに振り分けられる。メモリ領域との関係で境界が定められるみたいだが、自動判定されるのであまり気にしなくても良い気がする。整数ならではのメソッドは以下のあたり。oddとevenは「オッドアイ」の意味を考えると連想できることに気付いた。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;1.odd? # =&amp;gt; true
1.even? # =&amp;gt; false

1.next # =&amp;gt; 2
2.succ # =&amp;gt; 3
3.pred # =&amp;gt; 2

56.chr # =&amp;gt; &amp;quot;8&amp;quot; 文字コードで対応する文字列を返す

&amp;quot;123&amp;quot;.to_i # =&amp;gt; 123
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;浮動小数点数:3474e642b2d5b6a8e3b2c1120e2a383c&#34;&gt;浮動小数点数&lt;/h2&gt;

&lt;p&gt;Floatクラス。あまり意識せずに使っても勝手にFloatクラス扱いしてくれたりするので楽。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;num = 2.0 / 2
num.class # =&amp;gt; Float
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;有理数無理数:3474e642b2d5b6a8e3b2c1120e2a383c&#34;&gt;有理数無理数&lt;/h2&gt;

&lt;p&gt;Rationalが有理数クラスなわけだが、プログラミングにおいて無理数有理数の別が必要になる場面が想定できない数学オンチなのでよくわからん。Ruby Silverにも出なかった気がするし割愛でいっかな。。。なお複素数は文字通りComplexクラス。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Ruby基礎復習(2) Stringクラス</title>
      <link>http://chroju.github.io/blog/2015/03/15/study-ruby-string/</link>
      <pubDate>Sun, 15 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>http://chroju.github.io/blog/2015/03/15/study-ruby-string/</guid>
      <description>&lt;p&gt;パーフェクトRuby p.148から学習。文字列ことStringクラス。&lt;/p&gt;

&lt;p&gt;まずは基本操作系。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;s = &amp;quot;hoge&amp;quot;
s.empty? # =&amp;gt; false
s.length # =&amp;gt; 4
s.size # =&amp;gt; 4
s.bitesize # =&amp;gt; 8
s.include?(&amp;quot;og&amp;quot;) =&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;演算子での操作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;&#39;hoge&#39; + &#39;fuga&#39; # =&amp;gt; &#39;hogefuga&#39;
&#39;hoge&#39; * 3 =&amp;gt; &#39;hogehogehoge&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;破壊的な文字列の追加。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;s = &amp;quot;hoge&amp;quot;
s &amp;lt;&amp;lt; &amp;quot;fuga&amp;quot; # =&amp;gt; &amp;quot;hogefuga&amp;quot;
s.concat(&amp;quot;piyo&amp;quot;) # =&amp;gt; &amp;quot;hogefugapiyo&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;切り出し。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;s = &amp;quot;hogefuga&amp;quot;
s.slice(3) # =&amp;gt; &amp;quot;e&amp;quot;
s.slice(2,5) # =&amp;gt; &amp;quot;gefu&amp;quot;
s.slice(-4,2) # =&amp;gt; &amp;quot;fu&amp;quot;
s.slice(2..5) # =&amp;gt; &amp;quot;gefu&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;#slice&lt;/code&gt;を使わず、以下記法でも同等。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;s = &amp;quot;hogefuga&amp;quot;
s[3] # =&amp;gt; &amp;quot;e&amp;quot;
s[2,5] # =&amp;gt; &amp;quot;gefu&amp;quot;
s[-4,2] # =&amp;gt; &amp;quot;fu&amp;quot;
s[2..5] # =&amp;gt; &amp;quot;gefu&amp;quot;
s[//]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;文字列の整形に関するメソッドいろいろ。特に&lt;code&gt;#chop&lt;/code&gt;と&lt;code&gt;#chomp&lt;/code&gt;とか紛らわしいとよく言われる。英単語の意味するところとしてchop＝刻むってことで1文字削除されるのはわかるが、そこにmが足されると改行コードの削除になるのはなぜなんだろう。。。あと&lt;code&gt;#squeeze&lt;/code&gt;なんかは使う場面がいまいち想像できない。&lt;/p&gt;

&lt;p&gt;なお、ここにあるメソッドはすべて非破壊的。末尾に&lt;code&gt;!&lt;/code&gt;を付けることで破壊的操作になる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;s = &amp;quot; aaa &amp;quot;
s.strip # =&amp;gt; &amp;quot;aaa&amp;quot;
s.rstrip # =&amp;gt; &amp;quot; aaa&amp;quot;
s.lstrip # =&amp;gt; &amp;quot;aaa &amp;quot;

s = &amp;quot;aaa\n\n&amp;quot;
s.chomp # =&amp;gt; &amp;quot;aaa\n&amp;quot;
s = &amp;quot;abcd&amp;quot;
s.chop # =&amp;gt; &amp;quot;abc&amp;quot;

s = &amp;quot;aaaabbbbcccc&amp;quot;
s.squeeze # =&amp;gt; &amp;quot;abc&amp;quot;
s.squeeze(&#39;ab&#39;) # =&amp;gt; &amp;quot;abccc&amp;quot;

&amp;quot;ABC&amp;quot;.downcase # =&amp;gt; &amp;quot;abc&amp;quot;
&amp;quot;def&amp;quot;.upcase # =&amp;gt; &amp;quot;DEF&amp;quot;
&amp;quot;Abc&amp;quot;.swapcase # =&amp;gt; &amp;quot;aBC&amp;quot;
&amp;quot;tITle&amp;quot;.capitalize # =&amp;gt; &amp;quot;Title&amp;quot;

&amp;quot;abc&amp;quot;.reverse # =&amp;gt; &amp;quot;cba&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;置換。第一引数で検索を行い、ヒットした箇所を第二引数で置換するか、あるいはブロックに引き渡して操作、という建て付けのよう。&lt;code&gt;#sub&lt;/code&gt;だと最初に一致したもののみ、&lt;code&gt;#gsub&lt;/code&gt;だとヒットしたすべての箇所が置換される。これも破壊的、非破壊的の2種類あり。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;&amp;quot;aaaa&amp;quot;.sub(&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;) # =&amp;gt; &amp;quot;baaa&amp;quot;
&amp;quot;24-1-365&amp;quot;.gsub(/[0-9]+/) {|str| str.to_i.succ} # =&amp;gt; 25-2-366
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配列への変換。&lt;code&gt;#split&lt;/code&gt;で第一引数に指定した文字をセパレータとした分割が可能。第二引数には分割最大数が指定できる。また1文字ずつ操作したい場合は&lt;code&gt;#each_char&lt;/code&gt;が使える。ブロックへの引き渡しも可能。似たところで&lt;code&gt;#each_byte&lt;/code&gt;もある。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;str = &amp;quot;Alice, Bob, Charlie&amp;quot;

str.split(&amp;quot;,&amp;quot;) # =&amp;gt; [&amp;quot;Alice&amp;quot;, &amp;quot;Bob&amp;quot;, &amp;quot;Charlie&amp;quot;]
&amp;quot;Alice&amp;quot;.each_char.to_a # =&amp;gt; [&amp;quot;A&amp;quot;,&amp;quot;l&amp;quot;,&amp;quot;i&amp;quot;,&amp;quot;c&amp;quot;,&amp;quot;e&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Ruby基礎復習(1) 基礎文法</title>
      <link>http://chroju.github.io/blog/2015/03/08/study-ruby-grammer/</link>
      <pubDate>Sun, 08 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>http://chroju.github.io/blog/2015/03/08/study-ruby-grammer/</guid>
      <description>

&lt;p&gt;去年末から今年のはじめにかけてRuby Silver/Goldの再受験無料キャンペーンってのやってて、おーこりゃちょうどいいわーと思って取りあえず受けたら見事に落ちたんですけど、その後再受験申し込み期間あるの忘れてて棒に振るとかよくわからんことやりました。そのままなんとなーくやる気なくなってたけど、さすがにSilverクラスの知識はきちんと押さえるべきだろってことで、しばらく手元の『パーフェクトRuby』使って自分用チートシートっぽくまとめてみます。超基礎なので退屈な記事が続く予定。&lt;/p&gt;

&lt;p&gt;今回は文法面で自分がつまずいたポイントまとめる。&lt;/p&gt;

&lt;h2 id=&#34;変数のスコープ:5b29f8f1a23663f06837665ce8693447&#34;&gt;変数のスコープ&lt;/h2&gt;

&lt;p&gt;ローカル変数、グローバル変数、インスタンス変数、グローバル変数がまず基本にある。それぞれ文字通りではあり、ローカル変数は最も局所的なスコープ、グローバルはどこからでも参照可能（あまり使わない？）、インスタンス変数は個々のインスタンスに属する変数、クラス変数はクラス間で共有される変数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def display_local
  puts hoge
end

def display_global
  puts $hoge
end

$hoge = &amp;quot;Hello, world!&amp;quot;

display_local # =&amp;gt; NameError: undefined local variable or method `hoge&#39; for main:Object
display_global # =&amp;gt; &amp;quot;Hello, world!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Hoge
  @@class_var = &amp;quot;Hello, world from class!&amp;quot;
  
  def display_class_var
    puts @@class_var
  end

  attr_accessor :ins_var
end

i = Hoge.new
j = Hoge.new

i.display_class_var # =&amp;gt; &amp;quot;Hello, world from class!&amp;quot;
j.display_class_var # =&amp;gt; &amp;quot;Hello, world from class!&amp;quot;
i.ins_var = 1
j.ins_var = 2
i.ins_var # =&amp;gt; 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;しかし改めてattr_accessorというのは便利ですね。&lt;/p&gt;

&lt;p&gt;問題はローカル変数とブロック、メソッドとの関係で、わりと理解できてなかった。やりがちだけど、メソッドの中からメソッド外のローカル変数は参照できない。一方でブロックの中からブロック外のローカル変数は&lt;strong&gt;参照できる。&lt;/strong&gt;一方でブロック内のみで宣言されている変数は、ブロックローカル変数扱いになり外から参照できない。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;hoge = &amp;quot;hoge&amp;quot;

def hello_hoge
  puts hoge
end

hello_hoge # =&amp;gt; NameError: undefined local variable or method `hoge&#39; for main:Object
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;i = 1

3.times do |j|
  i = i + j
  block_local = &#39;in block&#39;
end

puts i # =&amp;gt; 4
puts block_local # =&amp;gt; NameError
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;rangeクラス:5b29f8f1a23663f06837665ce8693447&#34;&gt;Rangeクラス&lt;/h2&gt;

&lt;p&gt;Ruby Silver受けるまで、恥ずかしながら1..10みたいのがクラスだということを知りませんでした。Rangeクラスってのがあるのね。。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;range1 = 1..4
range2 = 1...4
range1.class # =&amp;gt; Range

range1.each do |i|
  puts i
end # =&amp;gt; 1,2,3,4

range1.include?(4) # =&amp;gt; true
range2.include?(4) # =&amp;gt; false
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;三項演算子:5b29f8f1a23663f06837665ce8693447&#34;&gt;三項演算子&lt;/h2&gt;

&lt;p&gt;苦手。ついでに後置if/unlessもよく使うので頭に置いとく。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;0.zero? ? &#39;0です&#39; : &#39;0じゃないです&#39; # =&amp;gt; &#39;0です&#39;
puts &#39;0です&#39; if 0.zero? # =&amp;gt; &#39;0です&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;rescue:5b29f8f1a23663f06837665ce8693447&#34;&gt;rescue&lt;/h2&gt;

&lt;p&gt;rescue節を複数書いた場合、最初に該当したrescue節で捕捉され、その後のrescue節は捨象される。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;begin
  raise &#39;StandardError&#39;
rescue LoadError =&amp;gt; e
  puts &#39;これはloaderrorです&#39;
rescue StandardError =&amp;gt; e
  puts &#39;これはstandarderrorです&#39;
rescue Exception =&amp;gt; e
  puts &#39;これはなにかエラーです&#39;
end # =&amp;gt; &#39;これはstandarderrorです&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;今後のtodo:5b29f8f1a23663f06837665ce8693447&#34;&gt;今後のtodo&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Hashの扱い（というかEnumerable）&lt;/li&gt;
&lt;li&gt;Time/Date関連の扱い&lt;/li&gt;
&lt;li&gt;Fileの扱い&lt;/li&gt;
&lt;li&gt;組み込みクラスの言語仕様再確認（特に破壊的非破壊的のあたり）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;まーぶっっちゃけ全部だな。。。。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Webスクレイピング手法は何かしら身に付けると便利そう</title>
      <link>http://chroju.github.io/blog/2014/08/24/2014-08-24-post/</link>
      <pubDate>Sun, 24 Aug 2014 00:00:00 +0000</pubDate>
      
      <guid>http://chroju.github.io/blog/2014/08/24/2014-08-24-post/</guid>
      <description>&lt;p&gt;最近&lt;a href=&#34;http://tokyoscrapper.connpass.com/event/7107/&#34;&gt;Webスクレイピング勉強会&lt;/a&gt;が開かれましたが、自分これは「補欠」になってしまった上に別の予定が入ってしまって行けなくなり、なので自分なりにスクレイピングやってみました。人気の勉強会ってすぐ満席になりますよね。。ホントは勉強会情報とかすくれーぴんぐして逃さずゲトできるようになりたい。まぁこの分野は先人が作ったサービス等いろいろありますが、push型の配信してくれるものってまだない気がするのよね（あったっけ？）&lt;/p&gt;

&lt;p&gt;Ruby好きなので使ったのはMechanizeです。nokogiriではない。ネットバンクから毎月残高拾ってきて記録してって手でやってたんだけど、いい加減自動化できないかと思いまして。なのでログイン処理とかまで任せるためにMechanize。&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/6cfb9869b7733d362af3.js&#34;&gt; &lt;/script&gt;

&lt;p&gt;で、使ってみた結果、これめちゃくちゃ便利というか、Web上に掲載されているあらゆるデータを抽出して使い回せるようになるので、やり方一つぐらい身に付けといて損はない気がしますね。&lt;/p&gt;

&lt;p&gt;冒頭に挙げたWebスクレイピング勉強会の第2回で&lt;a href=&#34;http://dev.classmethod.jp/study_meeting/web-scraping-tokyo-2nd/&#34;&gt;kimonoの中の人がしゃべっていた&lt;/a&gt;みたいですが、その中でも「セマンティックWebは失敗だった。だからkimonoが必要なんだ」という考え方にはわりと共感できるところがあります。Webってこれだけ情報に溢れたのに、そこから情報を抽出する手立てが限られているのは勿体ないですよね。&lt;/p&gt;

&lt;p&gt;ただ、kimonoが最終解のままで良いとも思っていなくて、セマンティックWebは失敗したのかもしれないけど、それに代わるアーキテクチャは何かしら必要なんじゃないかと。Web標準への準拠という、フロントサイドの思想がだいぶ一般的になってきた今日、次に考えていくべきはアーキテクチャの標準化ではないかという気がします。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>