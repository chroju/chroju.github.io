<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ruby on the world as code</title>
    <link>https://chroju.github.io/categories/ruby/</link>
    <description>Recent content in Ruby on the world as code</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <copyright>written by chroju</copyright>
    <lastBuildDate>Sun, 03 May 2015 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://chroju.github.io/categories/ruby/atom.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Hash与えるとGoogleスプレッドシートに入力してくれるRubyスクリプト</title>
      <link>https://chroju.github.io/blog/2015/05/03/google-spread-sheet-update-via-ruby/</link>
      <pubDate>Sun, 03 May 2015 00:00:00 +0000</pubDate>
      
      <guid>https://chroju.github.io/blog/2015/05/03/google-spread-sheet-update-via-ruby/</guid>
      <description>  つくった。動きとしては、項目名と入力値からなるハッシュを引数で与えてやることで、該当スプレッドシートの2列目に符合するキーがある場合、その値を一番右側の列に入力してくれる。符合するキーがない場合は、メッセージを吐いた上で最下行に新しい項目として追加する。
用途としては非常に個人的なもので、各種オンラインバンクの残高をスクレイピングしてハッシュで返してくれるスクリプトをいくつか作ってあったので、その戻り値を使ってオートで家計簿作れたらいいなーという思いによるものです。ハッシュのキーをそのままスプレッドシート内の項目名として使っているので、シンボルではなく文字列をキーとして使ってしまっているのがあまりよろしくないのかなぁとは思うのだが、いつか改善するってーことで、とりあえず動くものを作ることを優先させた。んで、これって結構汎用的に使えそうなスクリプトかもなと思って公開した次第。
Googleスプレッドシートをいじるのにはgoogle-drive-rubyというGemを使ってます。Githubはここ。def initialize内の処理は、このGemの初期設定によるものなので、Gemの方のReadme読んでもらえればよいかと。単純な話、GoogleのOAuth API使っているだけの話です。ただ、このコードだと叩くたびにブラウザからAPI使用許可を与えてやって、success codeをコピーしてコマンドラインで入力してやらなくちゃならないっていう手間があって、そこまで省く方法なにかありそうだけどまだ調べてない。あと気になっている点としては、このGemでセルの値を取ると、表示値しか取れないこと。式を入れているセルについては、式を取るか表示値を取るか選べるといいなぁと思ったんだけど、そこまではできないらしい。しかしまぁ、とにかくGoogleスプレッドシートという、APIで叩けるクラウドの表計算ソフトがあるというのは本当に便利なことですね、って感じ。
参考  RubyからGoogle SpreadSheet をいじるメモ - Qiita Google DriveのスプレッドシートにRubyでアクセスする方法 - Qiita  </description>
    </item>
    
    <item>
      <title>Ruby基礎学習(10) Mix-in</title>
      <link>https://chroju.github.io/blog/2015/04/24/ruby-study-mix-in/</link>
      <pubDate>Fri, 24 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>https://chroju.github.io/blog/2015/04/24/ruby-study-mix-in/</guid>
      <description> Mix-inの話と、それに似たもろもろ。他に詳しい記事があるので、これを読んでおけばいいような気はした。
参考  requireとincludeとextendとmodule_function(1) : As Sloth As Possible requireとincludeとextendとmodule_function(2) : As Sloth As Possible  require  Kernelモジュールのモジュール関数。 引数に与えたRubyライブラリを1回ロード、というか実行する。 使う場面としてはgemだとか自作のライブラリ（クラス）を読み込むときに指定する。 指定した引数は$LOAD_PATHに探しに行き、カレントディレクトリは含まれないため、パスの指定には少し注意が必要。 同じファイルを複数回requireしようとしても、1回しか読み込まない。  load  Kernelモジュールのモジュール関数。 requireと同様に外部ライブラリを実行するが、同じファイルを何度でも読み込める。 requireは拡張子の自動補完を行うが、loadは行わない。  include  Moduleクラスのインスタンスメソッド。 Moduleを引数に取り、メソッドや定数といった対象Moduleの性質を取り込む。 ArrayやHashがEnumerableの性質を持っているのはincludeしていることによるもの。 継承とは異なるが、メソッドの探索対象としてはスーパークラスよりincludeされたModuleの方が先になる。 同じモジュールを複数回読み込もうとしても、2回目以降は無視される。 Rubyは多重継承を認めていないが、その代わりの機能を果たすという位置付けらしい。  extend  Objectクラスのインスタンスメソッド。 引数に取ったModuleのメソッドを特異メソッドとして取り込める。  </description>
    </item>
    
    <item>
      <title>Ruby基礎復習(9) Dirクラス</title>
      <link>https://chroju.github.io/blog/2015/04/14/study-ruby-dir/</link>
      <pubDate>Tue, 14 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>https://chroju.github.io/blog/2015/04/14/study-ruby-dir/</guid>
      <description>『パーフェクトRuby』p.208より。
Dirクラスは基本としてカレントディレクトリ情報を持っていて、それを元としてディレクトリ操作ができる。従って多くの操作を特異メソッドで行うことができる。
Dir.pwd # =&amp;gt; &amp;quot;/Users/chroju&amp;quot; Dir.chdir(&amp;quot;/tmp&amp;quot;) Dir.pwd # =&amp;gt; &amp;quot;/tmp&amp;quot; Dir.home # =&amp;gt; &amp;quot;/Users/chroju&amp;quot;  ディレクトリに含まれるファイルはDir.entriesで配列として返り、Dir.foreachでEnumerableとして返る。またDir.globにより、パターンにマッチするファイルパスを配列で返すこともできる。Dir.globはDir[]と同義である。引数のディレクトリが存在するか確認する場合はDir.exists?を用いる。
Dir.entries(&#39;.&#39;) # =&amp;gt; [&amp;quot;.&amp;quot;, &amp;quot;..&amp;quot;, &amp;quot;bar&amp;quot;, &amp;quot;foo&amp;quot;, &amp;quot;baz&amp;quot;] Dir.foreach(&#39;.&#39;) {|d| p d } # =&amp;gt; &amp;quot;.&amp;quot;, &amp;quot;..&amp;quot;, &amp;quot;bar&amp;quot;, &amp;quot;foo&amp;quot;, &amp;quot;baz&amp;quot; Dir.glob(&#39;ba*&#39;) # =&amp;gt; [&amp;quot;bar&amp;quot;, &amp;quot;baz&amp;quot;] Dir[&#39;ba*&#39;] # =&amp;gt; [&amp;quot;bar&amp;quot;, &amp;quot;baz&amp;quot;] Dir.exists?(&amp;quot;hoo&amp;quot;) # =&amp;gt; false  ディレクトリの削除、生成等も特異メソッドにて。
Dir.mkdir &#39;foo&#39;, 0755 # パーミッション0755でfooディレクトリを生成 Dir.rmdir &#39;foo&#39; # fooディレクトリを削除するが、対象ディレクトリは空である必要がある Dir.delete &#39;foo&#39; # Dir.rmdirと同義 Dir.unlink &#39;foo&#39; # Dir.rmdirと同義  Dir.</description>
    </item>
    
    <item>
      <title>Ruby基礎復習(8) Fileクラス</title>
      <link>https://chroju.github.io/blog/2015/04/10/study-ruby-file-i-o/</link>
      <pubDate>Fri, 10 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>https://chroju.github.io/blog/2015/04/10/study-ruby-file-i-o/</guid>
      <description>『パーフェクトRuby』p.196より。わりと苦手な分野。
まずはファイルをひらく。#openして変数に格納してもいいし、ブロックを引き渡して処理させることもできる。後者の場合は処理が終わると自動でクローズしてくれるので、こっちの方が楽っぽい。#readはファイルの内容全体を読み込む一方、#getsを使うと1行ずつ読み込むことができる。あるいは#each_lineや#each_charといったメソッドも。
file = File.open(&#39;example.txt&#39;) p file.read # example.txtの内容を表示 file.close File.open &#39;example.txt&#39; do |file| p file.read end File.read(&#39;example.txt&#39;) File.open &#39;example.txt&#39; do |file| while line = file.gets p line end end File.open &#39;example.txt&#39; do |file| f.each_line do |line| p line end end  書き込むときは#openの第二引数にファイルを開くモードを指定する。デフォルトは&#39;r&#39;、すなわち読み込みモードで、他は以下の通り。基本はrが読み込み、wが書き込み、aが追記で、+を付けると読み書き両用モードになる。またbを後置するとバイナリモードで開かれる。
| r | 読み込みモード | | r+ | 読み書き両用モード（読み書き位置は先頭から） | | w | 上書き書き込みモード | | w+ | 新規作成して読み書き両用モード | | a | 追記書き込みモード | | a+ | 追記読み書き両用モード（読み込み位置は先頭から、書き込みは追記形式） |</description>
    </item>
    
    <item>
      <title>Ruby基礎復習(7) Timeクラス</title>
      <link>https://chroju.github.io/blog/2015/04/06/study-ruby-time/</link>
      <pubDate>Mon, 06 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>https://chroju.github.io/blog/2015/04/06/study-ruby-time/</guid>
      <description>『パーフェクトRuby』p.190より。
Time#nowかTime#newで現在時刻が取得可能。
now = Time.now # =&amp;gt; 2015-03-16 23:25:32 +0900 new = Time.new # =&amp;gt; 2015-03-16 23:25:32 +0900 now.zone # =&amp;gt; &amp;quot;JST&amp;quot; now.getutc # =&amp;gt; 2015-03-16 14:25:32 UTC now.utc now.zone # =&amp;gt; &amp;quot;UTC&amp;quot;  現在時刻以外のTimeオブジェクトを生成するにはTime#atでUNIX秒を引数に指定するか、Time#utcかTime#localで直接時刻を指定する。
Time.at(0) # =&amp;gt; 1970-01-01 09:00:00 +0900 Time.utc(2015, 1, 1, 2, 30, 40, 100) # =&amp;gt; 2015-01-01 02:30:40 UTC (最後の100はマイクロ秒) Time.local(2015, 1, 1, 2, 30, 40, 100) # =&amp;gt; 2015-01-01 02:30:40 +0900  #to_i、#to_f、#to_rの戻り値はUNIX秒。#to_sで文字列表現が返る。#to_aは秒、分、時、日、月、年、曜日、その年の通算日数、夏時間の真偽判定、タイムゾーンの配列を返す。なお、この配列フォーマットを展開してTime#utcやTime#localの引数として与えることもできる。
now.to_i # =&amp;gt; 1426515932 now.</description>
    </item>
    
    <item>
      <title>Ruby基礎復習(6) Hash</title>
      <link>https://chroju.github.io/blog/2015/04/05/study-ruby-hash/</link>
      <pubDate>Sun, 05 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>https://chroju.github.io/blog/2015/04/05/study-ruby-hash/</guid>
      <description>『パーフェクトRuby』p.179より。
まず基本的なとこで。
hash = {hoge: 1, fuga: 2} hash.each do |key, val| p &amp;quot;#{key}: #{val}&amp;quot; end # =&amp;gt; &amp;quot;hoge: 1&amp;quot;, &amp;quot;fuga: 2&amp;quot; hash.each_key do |key| p key end # =&amp;gt; &amp;quot;hoge&amp;quot;, &amp;quot;fuga&amp;quot; hash.each_value do |val| p val end # =&amp;gt; &amp;quot;1&amp;quot;, &amp;quot;2&amp;quot; hash[:hoge] = 3 p hash # =&amp;gt; {hoge: 3, fuga: 2} hash[:piyo] = 4 p hash # =&amp;gt; {hoge: 3, fuga: 2, piyo: 4} hash.delete(:piyo) hash # =&amp;gt; {hoge: 3, fuga: 2} hash.</description>
    </item>
    
    <item>
      <title>Ruby基礎復習(5) 配列(Array)</title>
      <link>https://chroju.github.io/blog/2015/03/18/study-ruby-array/</link>
      <pubDate>Wed, 18 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>https://chroju.github.io/blog/2015/03/18/study-ruby-array/</guid>
      <description>『パーフェクトRuby』p.171より。
まずは配列の生成をいくつか。#new(a,b)で生成したとき、各要素は同じオブジェクトとなるので注意。またブロックで受け取ると、インデックスを引数としてブロック内の処理を実行した結果が値となる。
a1 = Array.new(3,1) # =&amp;gt; [1, 1, 1] a2 = Array.new(3, &amp;quot;hoge&amp;quot;) # =&amp;gt; [&amp;quot;hoge&amp;quot;, &amp;quot;hoge&amp;quot;, &amp;quot;hoge&amp;quot;] a3 = [&amp;quot;hoge&amp;quot;, &amp;quot;fuga&amp;quot;, &amp;quot;piyo&amp;quot;] # =&amp;gt; [&amp;quot;hoge&amp;quot;, &amp;quot;fuga&amp;quot;, &amp;quot;piyo&amp;quot;] a4 = Array.new(3) {|i| i * 5} # =&amp;gt; [0, 5, 10] a2[0] &amp;lt;&amp;lt; &amp;quot;fuga&amp;quot; p a2 # =&amp;gt; [&amp;quot;hogefuga&amp;quot;, &amp;quot;hogefuga&amp;quot;, &amp;quot;hogefuga&amp;quot;]  基本的な操作系メソッド。演算子メソッドは直感的でほんといいなーと思う。なお、#&amp;lt;&amp;lt;は#concatと同義。#==と#eql?も同義。
array = [&amp;quot;hoge&amp;quot;, &amp;quot;fuga&amp;quot;, &amp;quot;piyo&amp;quot;] array.length # =&amp;gt; 3 array.size # =&amp;gt; 3 array.empty? # =&amp;gt; false array.</description>
    </item>
    
    <item>
      <title>Ruby基礎復習(4) EnumerableとComparable</title>
      <link>https://chroju.github.io/blog/2015/03/17/study-ruby-enumerable-comparable/</link>
      <pubDate>Tue, 17 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>https://chroju.github.io/blog/2015/03/17/study-ruby-enumerable-comparable/</guid>
      <description>『パーフェクトRuby』p.164より。
一部組み込みクラスは、EnumerableやComparableというモジュールがincludeされている。前者は聞き慣れない英単語だが、&amp;rdquo;can be counted&amp;rdquo;の意味らしく、HashやArrayといった一定の集合を表すクラスにincludeされていて、繰り返し処理や要素抽出に関するメソッドを実装する。Comparableはその名の通り比較演算、具体的には#&amp;lt;=&amp;gt;の実装であり、NumericやStringにincludeされているらしい。
特に実装されるメソッド数が多いので、Enumerableについてじっくり見てみたい。
Enumerable まず繰り返し系。これだけでもかなり。。#each_consのconsって何の意味ですかね。他はだいたい字義からイメージできる動作をしてくれる。あと#each_with_objectがいまいち飲み込めてない。
(1..4).each_cons 2 do |a,b| p [a,b] end # =&amp;gt; [1,2] [2,3] [3,4] (1..4).each_slice 2 do |a,b| p [a,b] end # =&amp;gt; [1,2] [3,4] %(hoge fuga piyo).each_with_index do |value, index| p &amp;quot;#{index}: #{value}&amp;quot; end # =&amp;gt; 0: hoge 1: fuga 2: piyo (1..4).each_with_object([]) {|i, result| result &amp;lt;&amp;lt; i*2} # =&amp;gt; [2,4,6,8] (1..4).reverse_each do |i| p i end # =&amp;gt; 4,3,2,1 (1..4).cycle {|i| p i} # =&amp;gt; 1,2,3,4,1,2.</description>
    </item>
    
    <item>
      <title>Ruby基礎復習(3) Numericクラス</title>
      <link>https://chroju.github.io/blog/2015/03/16/study-ruby-numeric/</link>
      <pubDate>Mon, 16 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>https://chroju.github.io/blog/2015/03/16/study-ruby-numeric/</guid>
      <description>パーフェクトRuby p.144より。
判定系メソッド、#nonzeroが#zeroの真逆の動きではなくてちょっと混乱しそう。あと#integer?はあるけど#float?はないとか。
0.zero? # =&amp;gt; true 3.zero? # =&amp;gt; false 0.nonzero? # =&amp;gt; nil 1.nonzero? # =&amp;gt; 1 1.integer? # =&amp;gt; true 1.real? # =&amp;gt; true  演算子系の話は割愛するが、宇宙船演算子だけ注意しとく。右辺（引数）の方が大きければ負。左辺（レシーバ）が大きければ正。#sortではブロック内の戻り値が負の場合は2要素をそのまま、正の場合は逆順にして返してくる。宇宙船演算子を利用して昇順or降順に並べ替えることができる。
1 &amp;lt;=&amp;gt; 2 # =&amp;gt; -1 2 &amp;lt;=&amp;gt; 1 # =&amp;gt; 1 1 &amp;lt;=&amp;gt; 1 # =&amp;gt; 0 %w(aaaa aa aaa).sort { |a,b| a.length &amp;lt;=&amp;gt; b.length } # =&amp;gt; [&amp;quot;aa&amp;quot;, &amp;quot;aaa&amp;quot;, &amp;quot;aaaa&amp;quot;]  丸め。#roundが四捨五入。#ceilで切り上げ。#floorで切り捨て。馴染みのない英単語で覚えにくい。
1.4.round # =&amp;gt; 1 1.4.ceil # =&amp;gt; 2 1.</description>
    </item>
    
    <item>
      <title>Ruby基礎復習(2) Stringクラス</title>
      <link>https://chroju.github.io/blog/2015/03/15/study-ruby-string/</link>
      <pubDate>Sun, 15 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>https://chroju.github.io/blog/2015/03/15/study-ruby-string/</guid>
      <description>パーフェクトRuby p.148から学習。文字列ことStringクラス。
まずは基本操作系。
s = &amp;quot;hoge&amp;quot; s.empty? # =&amp;gt; false s.length # =&amp;gt; 4 s.size # =&amp;gt; 4 s.bitesize # =&amp;gt; 8 s.include?(&amp;quot;og&amp;quot;) =&amp;gt; true  演算子での操作。
&#39;hoge&#39; + &#39;fuga&#39; # =&amp;gt; &#39;hogefuga&#39; &#39;hoge&#39; * 3 =&amp;gt; &#39;hogehogehoge&#39;  破壊的な文字列の追加。
s = &amp;quot;hoge&amp;quot; s &amp;lt;&amp;lt; &amp;quot;fuga&amp;quot; # =&amp;gt; &amp;quot;hogefuga&amp;quot; s.concat(&amp;quot;piyo&amp;quot;) # =&amp;gt; &amp;quot;hogefugapiyo&amp;quot;  切り出し。
s = &amp;quot;hogefuga&amp;quot; s.slice(3) # =&amp;gt; &amp;quot;e&amp;quot; s.slice(2,5) # =&amp;gt; &amp;quot;gefu&amp;quot; s.slice(-4,2) # =&amp;gt; &amp;quot;fu&amp;quot; s.</description>
    </item>
    
    <item>
      <title>Ruby基礎復習(1) 基礎文法</title>
      <link>https://chroju.github.io/blog/2015/03/08/study-ruby-grammer/</link>
      <pubDate>Sun, 08 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>https://chroju.github.io/blog/2015/03/08/study-ruby-grammer/</guid>
      <description>去年末から今年のはじめにかけてRuby Silver/Goldの再受験無料キャンペーンってのやってて、おーこりゃちょうどいいわーと思って取りあえず受けたら見事に落ちたんですけど、その後再受験申し込み期間あるの忘れてて棒に振るとかよくわからんことやりました。そのままなんとなーくやる気なくなってたけど、さすがにSilverクラスの知識はきちんと押さえるべきだろってことで、しばらく手元の『パーフェクトRuby』使って自分用チートシートっぽくまとめてみます。超基礎なので退屈な記事が続く予定。
今回は文法面で自分がつまずいたポイントまとめる。
変数のスコープ ローカル変数、グローバル変数、インスタンス変数、グローバル変数がまず基本にある。それぞれ文字通りではあり、ローカル変数は最も局所的なスコープ、グローバルはどこからでも参照可能（あまり使わない？）、インスタンス変数は個々のインスタンスに属する変数、クラス変数はクラス間で共有される変数。
def display_local puts hoge end def display_global puts $hoge end $hoge = &amp;quot;Hello, world!&amp;quot; display_local # =&amp;gt; NameError: undefined local variable or method `hoge&#39; for main:Object display_global # =&amp;gt; &amp;quot;Hello, world!&amp;quot;  class Hoge @@class_var = &amp;quot;Hello, world from class!&amp;quot; def display_class_var puts @@class_var end attr_accessor :ins_var end i = Hoge.new j = Hoge.new i.display_class_var # =&amp;gt; &amp;quot;Hello, world from class!&amp;quot; j.display_class_var # =&amp;gt; &amp;quot;Hello, world from class!</description>
    </item>
    
    <item>
      <title>Webスクレイピング手法は何かしら身に付けると便利そう</title>
      <link>https://chroju.github.io/blog/2014/08/24/2014-08-24-post/</link>
      <pubDate>Sun, 24 Aug 2014 00:00:00 +0000</pubDate>
      
      <guid>https://chroju.github.io/blog/2014/08/24/2014-08-24-post/</guid>
      <description>最近Webスクレイピング勉強会が開かれましたが、自分これは「補欠」になってしまった上に別の予定が入ってしまって行けなくなり、なので自分なりにスクレイピングやってみました。人気の勉強会ってすぐ満席になりますよね。。ホントは勉強会情報とかすくれーぴんぐして逃さずゲトできるようになりたい。まぁこの分野は先人が作ったサービス等いろいろありますが、push型の配信してくれるものってまだない気がするのよね（あったっけ？）
Ruby好きなので使ったのはMechanizeです。nokogiriではない。ネットバンクから毎月残高拾ってきて記録してって手でやってたんだけど、いい加減自動化できないかと思いまして。なのでログイン処理とかまで任せるためにMechanize。
 で、使ってみた結果、これめちゃくちゃ便利というか、Web上に掲載されているあらゆるデータを抽出して使い回せるようになるので、やり方一つぐらい身に付けといて損はない気がしますね。
冒頭に挙げたWebスクレイピング勉強会の第2回でkimonoの中の人がしゃべっていたみたいですが、その中でも「セマンティックWebは失敗だった。だからkimonoが必要なんだ」という考え方にはわりと共感できるところがあります。Webってこれだけ情報に溢れたのに、そこから情報を抽出する手立てが限られているのは勿体ないですよね。
ただ、kimonoが最終解のままで良いとも思っていなくて、セマンティックWebは失敗したのかもしれないけど、それに代わるアーキテクチャは何かしら必要なんじゃないかと。Web標準への準拠という、フロントサイドの思想がだいぶ一般的になってきた今日、次に考えていくべきはアーキテクチャの標準化ではないかという気がします。</description>
    </item>
    
  </channel>
</rss>